# ê²€ìˆ˜ ì§„í–‰ ëŒ€ì‹œë³´ë“œ - ì˜ˆìƒ ë‚¨ì€ ì‹œê°„ ì¶”ì • ì •í™•ë„ ê°œì„  ë¶„ì„

## ğŸ“‹ ìš”ì•½

í˜„ì¬ ê²€ìˆ˜ ëŒ€ì‹œë³´ë“œì˜ ì˜ˆìƒ ë‚¨ì€ ì‹œê°„(ETA)ì´ ì‹¤ì œ ì‘ì—… ì‹œê°„ê³¼ í° ì˜¤ì°¨ë¥¼ ë³´ì´ëŠ” ë¬¸ì œë¥¼ ë¶„ì„í•˜ê³  í•´ê²° ë°©ì•ˆì„ ì œì‹œí•©ë‹ˆë‹¤.

**ë¬¸ì œ**: ëŒ€ì‹œë³´ë“œ í‘œì‹œ ETAì™€ ì‹¤ì œ ì™„ë£Œ ì‹œê°„ ê°„ ì˜¤ì°¨ê°€ í¼
**ì˜í–¥**: ì‚¬ìš©ìê°€ ê²€ìˆ˜ ì™„ë£Œ ì‹œê°„ì„ ì •í™•íˆ ì˜ˆì¸¡í•  ìˆ˜ ì—†ì–´ ì‘ì—… ê³„íš ìˆ˜ë¦½ ì–´ë ¤ì›€
**ìš°ì„ ìˆœìœ„**: ë†’ìŒ (ì‚¬ìš©ì ê²½í—˜ ì§ì ‘ ì˜í–¥)

---

## ğŸ” í˜„ì¬ ì‹œìŠ¤í…œ êµ¬ì¡° ë¶„ì„

### 1. ì‹œê°„ ì¶”ì • ì‹œìŠ¤í…œ ì „ì²´ íë¦„

```
[ê²€ìˆ˜ ì‹œì‘]
    â†“
[ValidationTimePredictor] â† ê³¼ê±° ì´ë ¥ ê¸°ë°˜ ì´ˆê¸° ì˜ˆì¸¡
    â†“ (SeedPredictions)
[AdaptiveRemainingTimeEstimator] â† ì‹¤ì‹œê°„ ì§„í–‰ë¥  ê¸°ë°˜ ì ì‘í˜• ì¶”ì •
    â†“ (UpdateProgress ë§¤ 1ì´ˆ)
[StageSummaryCollectionViewModel]
    â†“
[ëŒ€ì‹œë³´ë“œ UI] â†’ ì‚¬ìš©ìì—ê²Œ í‘œì‹œ
```

### 2. í•µì‹¬ ì»´í¬ë„ŒíŠ¸

#### A. ValidationTimePredictor (ì´ˆê¸° ì˜ˆì¸¡)
**ìœ„ì¹˜**: `SpatialCheckPro.GUI/Models/ValidationTimePredictor.cs`

**ì—­í• **: ê²€ìˆ˜ ì‹œì‘ ì „ ë‹¨ê³„ë³„ ì˜ˆìƒ ì†Œìš” ì‹œê°„ ê³„ì‚°
- ê³¼ê±° ì‹¤í–‰ ì´ë ¥ ê¸°ë°˜ ìœ ì‚¬ë„ ë§¤ì¹­
- ê°€ì¤‘ í‰ê· ìœ¼ë¡œ ì˜ˆì¸¡ê°’ ì‚°ì¶œ
- ë©”íŠ¸ë¦­ë³„ ìŠ¤ì¼€ì¼ë§ ì ìš©

**ì…ë ¥ ë©”íŠ¸ë¦­**:
- í…Œì´ë¸” ìˆ˜ (TableCount)
- ì´ í”¼ì²˜ ìˆ˜ (TotalFeatureCount)
- ìŠ¤í‚¤ë§ˆ í•„ë“œ ìˆ˜ (SchemaFieldCount)
- ì§€ì˜¤ë©”íŠ¸ë¦¬ ê²€ì‚¬ í•­ëª© ìˆ˜ (GeometryCheckItemCount)
- ê´€ê³„ ê·œì¹™ ìˆ˜ (RelationRuleCount)
- ì†ì„± ì»¬ëŸ¼ ìˆ˜ (AttributeColumnCount)

**ì¶œë ¥**: ë‹¨ê³„ë³„ ì˜ˆì¸¡ ì‹œê°„ (ì´ˆ) - Stage 0~5

#### B. AdaptiveRemainingTimeEstimator (ì‹¤ì‹œê°„ ì ì‘í˜• ì¶”ì •)
**ìœ„ì¹˜**: `SpatialCheckPro/Services/RemainingTime/AdaptiveRemainingTimeEstimator.cs`

**ì—­í• **: ì‹¤í–‰ ì¤‘ ì‹¤ì‹œê°„ ì§„í–‰ë¥ ì„ ë°˜ì˜í•˜ì—¬ ë‚¨ì€ ì‹œê°„ ë™ì  ì¶”ì •
- EWMA (Exponential Weighted Moving Average) ê¸°ë°˜ ìŠ¤ë¬´ë”©
- ë‹¨ìœ„ ì²˜ë¦¬ìœ¨(unit rate)ê³¼ ì§„í–‰ë¥ (progress rate) ì´ì¤‘ ì¶”ì 
- ì‹ ë¢°ë„(confidence) ê³„ì‚°

**í•µì‹¬ ì•Œê³ ë¦¬ì¦˜**:
```csharp
// 1. ë‹¨ìœ„ ê¸°ë°˜ ì¶”ì • (ìš°ì„ ìˆœìœ„ ë†’ìŒ)
if (processedUnits > 0 && totalUnits > 0)
{
    remainingUnits = totalUnits - processedUnits;
    remainingSeconds = remainingUnits / smoothedUnitRate;
}

// 2. ì§„í–‰ë¥  ê¸°ë°˜ ì¶”ì • (fallback)
if (progressPercent > 5% && progressPercent < 100%)
{
    estimatedTotal = elapsedSeconds / progressRatio;
    remainingSeconds = estimatedTotal - elapsedSeconds;
}

// 3. ì˜ˆì¸¡ê°’ ì‚¬ìš© (ë°ì´í„° ë¶€ì¡± ì‹œ)
return predictedDuration;
```

**EWMA ìŠ¤ë¬´ë”©**:
```csharp
smoothedRate = alpha * currentRate + (1 - alpha) * previousSmoothedRate
// alpha = 0.3 (ê³ ì •ê°’)
```

---

## âš ï¸ ì‹ë³„ëœ ë¬¸ì œì 

### ë¬¸ì œ 1: ì´ˆê¸° ì˜ˆì¸¡ ë°ì´í„° ë¶€ì¡± ë° ë‹¨ìˆœí™”

**ìœ„ì¹˜**: `ValidationTimePredictor.cs:96-134`

**í˜„ìƒ**:
- ê¸°ë³¸ ì´ë ¥ ë°ì´í„°ê°€ ë‹¨ **2ê°œì˜ í•˜ë“œì½”ë”©ëœ ìƒ˜í”Œ**ë§Œ ì¡´ì¬
- ì‹¤ì œ DBì— ì €ì¥ëœ `StageDurationHistory` í…Œì´ë¸” í™œìš© ì•ˆ í•¨
- ìŠ¤ì¼€ì¼ë§ íŒ©í„°ê°€ ê²½í—˜ì  ì¶”ì¸¡ê°’ (0.8, 0.9 ë“±ì˜ power-law ê³„ìˆ˜)

**ì½”ë“œ ì¦ê±°**:
```csharp
// ValidationTimePredictor.cs:99-133
private void InitializeWithDefaultData()
{
    // ë‹¨ 2ê°œì˜ ìƒ˜í”Œë§Œ í•˜ë“œì½”ë”©
    _historyData.Runs.Add(new ValidationRunData { ... }); // ìƒ˜í”Œ 1
    _historyData.Runs.Add(new ValidationRunData { ... }); // ìƒ˜í”Œ 2
}

// ìŠ¤ì¼€ì¼ë§ (line 253-262)
3 => Math.Pow((double)totalFeatureCount / baseRun.TotalFeatureCount, 0.8),
4 => Math.Pow((double)relationRuleCount / baseRun.RelationRuleCount, 0.9),
```

**ì˜í–¥**:
- ìƒˆë¡œìš´ ë°ì´í„°ì…‹ì— ëŒ€í•œ ì˜ˆì¸¡ ì •í™•ë„ ë‚®ìŒ
- ì‹¤ì œ ë¹„ì„ í˜• ì²˜ë¦¬ íŒ¨í„´ì„ ë°˜ì˜í•˜ì§€ ëª»í•¨
- Stage 3 (ì§€ì˜¤ë©”íŠ¸ë¦¬ ê²€ì‚¬)ëŠ” í”¼ì²˜ë‹¹ ë³µì¡ë„ê°€ ì²œì°¨ë§Œë³„ì¸ë° ë‹¨ìˆœ ê°œìˆ˜ ê¸°ë°˜ ìŠ¤ì¼€ì¼ë§

**ì‹¬ê°ë„**: ğŸ”´ ë†’ìŒ

---

### ë¬¸ì œ 2: EWMA ì•ŒíŒŒê°’ ê³ ì • ë° ë¶€ì ì ˆí•œ ìŠ¤ë¬´ë”©

**ìœ„ì¹˜**: `AdaptiveRemainingTimeEstimator.cs:25`

**í˜„ìƒ**:
- ëª¨ë“  ë‹¨ê³„ì— ë™ì¼í•œ alpha = 0.3 ì ìš©
- ì´ˆê¸° ë‹¨ê³„(ìƒ˜í”Œ < 5ê°œ)ì™€ í›„ê¸° ë‹¨ê³„ êµ¬ë¶„ ì—†ìŒ
- ê¸‰ê²©í•œ ì†ë„ ë³€í™” ì‹œ ë°˜ì‘ ì§€ì—°

**ì½”ë“œ ì¦ê±°**:
```csharp
// AdaptiveRemainingTimeEstimator.cs:25
private const double EwmaAlpha = 0.3;  // ëª¨ë“  ë‹¨ê³„ ë™ì¼

// UpdateUnitRate (lines 250-252)
state.SmoothedUnitRate = state.SmoothedUnitRate <= 0
    ? rate
    : EwmaAlpha * rate + (1 - EwmaAlpha) * state.SmoothedUnitRate;
```

**ì´ë¡ ì  ë°°ê²½**:
- alpha = 0.3 â†’ ìµœê·¼ 3-4ê°œ ìƒ˜í”Œì— ì£¼ìš” ê°€ì¤‘ì¹˜ (effective window â‰ˆ 1/alpha)
- ì´ˆê¸°: ìƒ˜í”Œ ë¶€ì¡±ìœ¼ë¡œ ë¶ˆì•ˆì • â†’ ë†’ì€ alpha í•„ìš” (0.5~0.7)
- ì¤‘ê¸°: ì•ˆì •í™” â†’ ì¤‘ê°„ alpha ì ìš© (0.3~0.4)
- í›„ê¸°: ì •ë°€ ì¶”ì • â†’ ë‚®ì€ alpha í•„ìš” (0.1~0.2)

**ì‹¤ì œ ë¬¸ì œ ì‹œë‚˜ë¦¬ì˜¤**:
1. **Stage 3 ì´ˆë°˜**: ê°„ë‹¨í•œ í´ë¦¬ê³¤ â†’ ë¹ ë¥¸ ì²˜ë¦¬ â†’ ë‚™ê´€ì  ETA
2. **Stage 3 ì¤‘ë°˜**: ë³µì¡í•œ self-intersection ê²€ì‚¬ â†’ ê¸‰ê²©íˆ ëŠë ¤ì§ â†’ ETA ê°‘ìê¸° ì¦ê°€
3. **alpha = 0.3ìœ¼ë¡œëŠ” ë³€í™” ë°˜ì˜ ì§€ì—°** â†’ ì‚¬ìš©ìëŠ” "10ë¶„ ë‚¨ìŒ"ì—ì„œ "30ë¶„ ë‚¨ìŒ"ìœ¼ë¡œ ê¸‰ë³€í•˜ëŠ” ê²ƒì„ ë´„

**ì‹¬ê°ë„**: ğŸ”´ ë†’ìŒ

---

### ë¬¸ì œ 3: ë¹„ì„ í˜• ì²˜ë¦¬ íŒ¨í„´ ë¯¸ë°˜ì˜

**ìœ„ì¹˜**: `AdaptiveRemainingTimeEstimator.cs:190-219`

**í˜„ìƒ**:
- ì„ í˜• ì¶”ì •ë§Œ ì‚¬ìš©: `remainingSeconds = remainingUnits / constantRate`
- ì‹¤ì œ ê²€ìˆ˜ëŠ” **ë¹„ì„ í˜• ì²˜ë¦¬ ì‹œê°„** íŠ¹ì„±:
  - **Stage 3 (ì§€ì˜¤ë©”íŠ¸ë¦¬)**: ë³µì¡ë„ì— ë”°ë¼ O(n) ~ O(nÂ²) ê°€ë³€
  - **Stage 4 (ê´€ê³„)**: ì¡°ì¸ í¬ê¸°ì— ë”°ë¼ ì§€ìˆ˜ì  ì¦ê°€ ê°€ëŠ¥
  - **DB I/O**: ìºì‹œ íš¨ê³¼ë¡œ ì´ˆë°˜ ë¹ ë¦„ â†’ í›„ë°˜ ëŠë ¤ì§

**ë°ì´í„° ì¦ê±°** (ê¸°ë³¸ ìƒ˜í”Œ ë¶„ì„):
```
ìƒ˜í”Œ 1: Stage4 = 87.472ì´ˆ (RelationRuleCount = 39)
ìƒ˜í”Œ 2: Stage4 = 14.931ì´ˆ (RelationRuleCount = 664)
â†’ ê·œì¹™ ìˆ˜ 17ë°° ì¦ê°€í–ˆëŠ”ë° ì‹œê°„ì€ ì˜¤íˆë ¤ 1/6 ê°ì†Œ
â†’ ëª…ë°±í•œ ë¹„ì„ í˜•ì„±, ë‹¨ìˆœ ì„ í˜• ìŠ¤ì¼€ì¼ë§ ë¶ˆê°€
```

**ì‹œë‚˜ë¦¬ì˜¤ ì˜ˆì‹œ**:
```
ì‹¤ì œ ì§„í–‰:
- 0-25%: 2ë¶„ ì†Œìš” â†’ ETA ì¶”ì •: "6ë¶„ ë‚¨ìŒ" (25% â†’ 100% ê°€ì •)
- 25-50%: 5ë¶„ ì†Œìš” â†’ ETA ì¬ì¡°ì •: "15ë¶„ ë‚¨ìŒ" (í›„ë°˜ ë” ëŠë ¤ì§ ê°ì§€)
- 50-75%: 10ë¶„ ì†Œìš” â†’ ETA ì¬ì¡°ì •: "30ë¶„ ë‚¨ìŒ" (ê³„ì† ëŠë ¤ì§)
â†’ ì‚¬ìš©ìëŠ” ETAê°€ ê³„ì† ì¦ê°€í•˜ëŠ” ê²ƒì„ ë³´ê³  ì‹ ë¢° ìƒì‹¤
```

**ì‹¬ê°ë„**: ğŸ”´ ë†’ìŒ

---

### ë¬¸ì œ 4: ì§„í–‰ë¥  ì—…ë°ì´íŠ¸ ë¹ˆë„ ë¶ˆì¼ì¹˜

**ìœ„ì¹˜**: `ParallelProgressTracker.cs:24`, ê° Processor ë‚´ë¶€

**í˜„ìƒ**:
- ParallelProgressTrackerëŠ” 1ì´ˆë§ˆë‹¤ ì—…ë°ì´íŠ¸
- í•˜ì§€ë§Œ ì¼ë¶€ ProcessorëŠ” **ì²­í¬ ë‹¨ìœ„ë¡œë§Œ ì§„í–‰ë¥  ë³´ê³ ** (ì˜ˆ: 100ê°œ í”¼ì²˜ ì²˜ë¦¬ í›„)
- ê¸´ ì²˜ë¦¬ ì‹œê°„ ì²­í¬ ë™ì•ˆ ì§„í–‰ë¥  0% â†’ ê°‘ìê¸° 10% ì í”„

**ì˜í–¥**:
- ì§„í–‰ë¥ ì´ ë©ˆì¶˜ ê²ƒì²˜ëŸ¼ ë³´ì„ â†’ ETAê°€ ë¬´í•œëŒ€ë¡œ ë°œì‚°
- ê°‘ìê¸° ì í”„ â†’ ETAê°€ ê¸‰ê²©íˆ ê°ì†Œ
- ì‚¬ìš©ì í˜¼ë€ ê°€ì¤‘

**ì‹¬ê°ë„**: ğŸŸ¡ ì¤‘ê°„

---

### ë¬¸ì œ 5: ì‹ ë¢°ë„ ê³„ì‚°ì˜ ì˜ë¯¸ ì—†ìŒ

**ìœ„ì¹˜**: `AdaptiveRemainingTimeEstimator.cs:310-336`

**í˜„ìƒ**:
- ì‹ ë¢°ë„(confidence)ê°€ "ìƒ˜í”Œ ê°œìˆ˜"ì™€ "í¸ì°¨"ë§Œ ê³ ë ¤
- **ì‹¤ì œ ì˜ˆì¸¡ ì •í™•ë„ì™€ì˜ ìƒê´€ê´€ê³„ ê²€ì¦ ì•ˆ ë¨**
- ì‚¬ìš©ìì—ê²Œ í‘œì‹œë˜ì§€ë§Œ ì‹¤ì§ˆì  ê°€ì¹˜ ì—†ìŒ

**ì½”ë“œ**:
```csharp
// ë‹¨ìˆœíˆ ìƒ˜í”Œ >= 5ê°œë©´ confidence = 0.7
if (sampleCount >= RequiredSamplesForHighConfidence)
{
    confidence = Math.Max(confidence, 0.7);
    var deviation = CalculateDeviation(state.RecentUnitRates);
    if (deviation < 0.35) confidence = Math.Min(0.95, confidence + 0.2);
}
```

**ë¬¸ì œì **:
- í¸ì°¨ê°€ ì‘ì•„ë„ ì¶”ì„¸ê°€ ë³€í™”í•˜ëŠ” ì¤‘ì´ë©´ ì˜ˆì¸¡ì€ ë¶€ì •í™•
- ì‹ ë¢°ë„ 0.9ì¸ë° ì‹¤ì œ ì˜¤ì°¨ 300%ì¸ ê²½ìš° ë°œìƒ ê°€ëŠ¥

**ì‹¬ê°ë„**: ğŸŸ¡ ì¤‘ê°„

---

### ë¬¸ì œ 6: ì˜ˆì¸¡ê°’ í´ë°± ë¡œì§ ë¶€ì¬

**ìœ„ì¹˜**: `AdaptiveRemainingTimeEstimator.cs:218`

**í˜„ìƒ**:
- ì‹¤ì‹œê°„ ë°ì´í„°ê°€ ì´ìƒí•˜ê±°ë‚˜ ë¶€ì¡±í•  ë•Œ â†’ `return state.PredictedDuration`
- í•˜ì§€ë§Œ PredictedDurationë„ ë¶€ì •í™•í•œ ì´ˆê¸° ì˜ˆì¸¡ê°’
- **ì‹¤ì œ ê²½ê³¼ ì‹œê°„ì„ ì „í˜€ ë°˜ì˜í•˜ì§€ ì•ŠìŒ**

**ì‹œë‚˜ë¦¬ì˜¤**:
```
ì˜ˆì¸¡: Stage 3 = 10ì´ˆ
ì‹¤ì œ: 5ë¶„ ê²½ê³¼, 50% ì§„í–‰
â†’ ì§„í–‰ë¥  ë°ì´í„° ì´ìƒ ê°ì§€ â†’ PredictedDuration (10ì´ˆ) ë°˜í™˜
â†’ ëŒ€ì‹œë³´ë“œ: "10ì´ˆ ë‚¨ìŒ" (ì‹¤ì œë¡œëŠ” 5ë¶„ ë” í•„ìš”)
```

**ì‹¬ê°ë„**: ğŸŸ¡ ì¤‘ê°„

---

## ğŸ’¡ í•´ê²° ë°©ì•ˆ

### í•´ê²°ì±… 1: DB ê¸°ë°˜ ë™ì  ì˜ˆì¸¡ ëª¨ë¸ êµ¬ì¶•

**ëª©í‘œ**: ì‹¤ì œ ì‹¤í–‰ ì´ë ¥ì„ DBì—ì„œ ë¡œë“œí•˜ì—¬ ì˜ˆì¸¡ ì •í™•ë„ í–¥ìƒ

**êµ¬í˜„ ë‚´ìš©**:

1. **ValidationTimePredictor ê°œì„ **:
```csharp
// StageDurationHistoryEntityì—ì„œ ìµœê·¼ Nê°œ ì´ë ¥ ë¡œë“œ
public async Task<Dictionary<int, double>> PredictStageTimesAsync(
    ValidationRunContext context,
    IDbContextFactory<ValidationDbContext> dbFactory)
{
    await using var db = await dbFactory.CreateDbContextAsync();

    // ìµœê·¼ 30ì¼ ì´ë ¥, ìµœëŒ€ 100ê°œ
    var recentHistory = await db.StageDurationHistory
        .Where(h => h.CollectedAtUtc >= DateTime.UtcNow.AddDays(-30))
        .OrderByDescending(h => h.CollectedAtUtc)
        .Take(100)
        .ToListAsync();

    // ë©”íŠ¸ë¦­ ê¸°ë°˜ ìœ ì‚¬ë„ ê³„ì‚°
    var similarRuns = FindSimilarRuns(context, recentHistory);

    // Quantile Regressionìœ¼ë¡œ ë³´ìˆ˜ì  ì˜ˆì¸¡ (75th percentile)
    return CalculateQuantilePredictions(similarRuns, 0.75);
}
```

2. **Quantile Regression ì ìš©**:
   - ì¤‘ì•™ê°’(median) ëŒ€ì‹  **75th percentile** ì‚¬ìš©
   - ë³´ìˆ˜ì  ì˜ˆì¸¡ìœ¼ë¡œ "ë‚¨ì€ ì‹œê°„ ì¦ê°€" í˜„ìƒ ìµœì†Œí™”
   - ì‚¬ìš©ì ë§Œì¡±ë„ í–¥ìƒ (ì˜ˆìƒë³´ë‹¤ ë¹¨ë¦¬ ëë‚˜ë©´ ê¸ì •ì )

**ì˜ˆìƒ íš¨ê³¼**: ì´ˆê¸° ì˜ˆì¸¡ ì˜¤ì°¨ 30% â†’ 10% ê°ì†Œ

---

### í•´ê²°ì±… 2: ì ì‘í˜• EWMA ì•ŒíŒŒê°’ (Adaptive Alpha)

**ëª©í‘œ**: ì§„í–‰ ë‹¨ê³„ì— ë”°ë¼ EWMA smoothing ê°•ë„ ë™ì  ì¡°ì •

**êµ¬í˜„ ë‚´ìš©**:
```csharp
// AdaptiveRemainingTimeEstimator.cs
private double GetAdaptiveAlpha(StageEtaInternalState state, double progressPercent)
{
    // ì´ˆê¸° ë‹¨ê³„ (0-20%): ë†’ì€ alphaë¡œ ë¹ ë¥¸ ì ì‘
    if (progressPercent < 20 || state.RecentUnitRates.Count < 5)
    {
        return 0.6;
    }

    // ì¤‘ê¸° (20-70%): í‘œì¤€ alpha
    if (progressPercent < 70)
    {
        return 0.35;
    }

    // í›„ê¸° (70-100%): ë‚®ì€ alphaë¡œ ì•ˆì •í™”
    return 0.15;
}

// UpdateUnitRate ìˆ˜ì •
private void UpdateUnitRate(StageEtaInternalState state, long processedUnits, double elapsedSeconds)
{
    var rate = processedUnits / Math.Max(1.0, elapsedSeconds);
    if (!double.IsFinite(rate) || rate <= 0) return;

    var alpha = GetAdaptiveAlpha(state, state.LastProgressPercent); // ë™ì  ì•ŒíŒŒ

    state.SmoothedUnitRate = state.SmoothedUnitRate <= 0
        ? rate
        : alpha * rate + (1 - alpha) * state.SmoothedUnitRate;

    // ... ë‚˜ë¨¸ì§€ ë¡œì§
}
```

**íš¨ê³¼**:
- ì´ˆê¸°: ë¹ ë¥¸ ìˆ˜ë ´ (60% ë°˜ì˜)
- ì¤‘ê¸°: ê· í˜• ì¡íŒ ìŠ¤ë¬´ë”©
- í›„ê¸°: ì•ˆì •ì  ì¶”ì • (85% ê³¼ê±° ë°ì´í„° ë°˜ì˜)

**ì˜ˆìƒ íš¨ê³¼**: ì¤‘ë°˜ ì´í›„ ETA ë³€ë™ì„± 50% ê°ì†Œ

---

### í•´ê²°ì±… 3: ë¹„ì„ í˜• íŒ¨í„´ í•™ìŠµ (Polynomial Regression)

**ëª©í‘œ**: ì§„í–‰ë¥ -ì‹œê°„ ê³¡ì„ ì˜ ë¹„ì„ í˜•ì„±ì„ 2ì°¨ ë‹¤í•­ì‹ìœ¼ë¡œ ëª¨ë¸ë§

**êµ¬í˜„ ë‚´ìš©**:
```csharp
// EstimateRemaining ê°œì„ 
private TimeSpan? EstimateRemaining(StageEtaInternalState state, double elapsedSeconds,
    long processedUnits, long totalUnits)
{
    // ê¸°ì¡´ ì„ í˜• ì¶”ì •
    var linearEta = EstimateLinear(state, elapsedSeconds, processedUnits, totalUnits);

    // ìƒˆë¡œìš´ ë‹¤í•­ì‹ ì¶”ì • (ìƒ˜í”Œì´ ì¶©ë¶„í•  ë•Œë§Œ)
    if (state.RecentUnitRates.Count >= 10)
    {
        var polynomialEta = EstimatePolynomial(state, elapsedSeconds, processedUnits, totalUnits);

        // ê°€ì¤‘ í‰ê·  (ìƒ˜í”Œ ë§ì„ìˆ˜ë¡ ë‹¤í•­ì‹ ê°€ì¤‘ì¹˜ ì¦ê°€)
        var polyWeight = Math.Min(0.7, state.RecentUnitRates.Count / 30.0);
        var blendedSeconds = (1 - polyWeight) * linearEta.TotalSeconds
                           + polyWeight * polynomialEta.TotalSeconds;
        return TimeSpan.FromSeconds(blendedSeconds);
    }

    return linearEta;
}

private TimeSpan EstimatePolynomial(StageEtaInternalState state, double elapsed,
    long processed, long total)
{
    // ìµœê·¼ ìƒ˜í”Œë¡œ 2ì°¨ ë‹¤í•­ì‹ í”¼íŒ…: rate(t) = a + b*t + c*tÂ²
    var samples = state.RecentUnitRates.TakeLast(15).ToList();
    var (a, b, c) = FitQuadratic(samples);

    // í˜„ì¬ ì¶”ì„¸ ê¸°ë°˜ ë‚¨ì€ ì‹œê°„ ì ë¶„ ê³„ì‚°
    var currentProgress = (double)processed / total;
    var remainingProgress = 1.0 - currentProgress;

    // ë‹¤í•­ì‹ ì ë¶„ìœ¼ë¡œ ë‚¨ì€ ì‹œê°„ ê³„ì‚°
    var estimatedRemaining = IntegrateQuadratic(a, b, c, currentProgress, 1.0);

    return TimeSpan.FromSeconds(Math.Max(1, estimatedRemaining));
}
```

**ìˆ˜í•™ì  ê·¼ê±°**:
- ì„ í˜•: `rate = constant` â†’ `time = remaining / rate`
- 2ì°¨: `rate(progress) = a + b*progress + c*progressÂ²`
- ì ë¶„: `time = âˆ«[pâ†’1] (1/rate(x)) dx`

**ì˜ˆìƒ íš¨ê³¼**: Stage 3, 4ì˜ ì¤‘í›„ë°˜ ì˜ˆì¸¡ ì˜¤ì°¨ 40% â†’ 15% ê°ì†Œ

---

### í•´ê²°ì±… 4: ì§„í–‰ë¥  ë³´ê³  ì£¼ê¸° í‘œì¤€í™”

**ëª©í‘œ**: ëª¨ë“  Processorê°€ ì¼ê´€ëœ ì£¼ê¸°ë¡œ ì§„í–‰ë¥  ë³´ê³ 

**êµ¬í˜„ ë‚´ìš©**:

1. **IProgressReporter ì¸í„°í˜ì´ìŠ¤ í‘œì¤€í™”**:
```csharp
public interface IProgressReporter
{
    /// <summary>
    /// ìµœì†Œ ë³´ê³  ì£¼ê¸°: 2ì´ˆ ë˜ëŠ” ì „ì²´ì˜ 1% ì¤‘ ì§§ì€ ê²ƒ
    /// </summary>
    TimeSpan MinReportInterval { get; }

    void ReportProgress(double percent, long processed, long total);
}
```

2. **Processorë³„ ì ìš©**:
```csharp
// GeometryCheckProcessor ì˜ˆì‹œ
private DateTime _lastProgressReport = DateTime.MinValue;
private const double MIN_PROGRESS_DELTA = 0.5; // 0.5% ë³€í™” ì‹œ ë³´ê³ 

foreach (var feature in features)
{
    ProcessFeature(feature);
    processed++;

    var currentProgress = (double)processed / total * 100;
    var timeSinceLastReport = DateTime.Now - _lastProgressReport;

    if (timeSinceLastReport >= TimeSpan.FromSeconds(2) ||
        currentProgress - _lastReportedProgress >= MIN_PROGRESS_DELTA)
    {
        progress?.Report(new ValidationProgress { ... });
        _lastProgressReport = DateTime.Now;
        _lastReportedProgress = currentProgress;
    }
}
```

**ì˜ˆìƒ íš¨ê³¼**: ì§„í–‰ë¥  ì •ì²´ ì¸ì‹ 90% ê°ì†Œ, ETA ë°œì‚° í˜„ìƒ ì œê±°

---

### í•´ê²°ì±… 5: ì•™ìƒë¸” ì˜ˆì¸¡ (Ensemble Prediction)

**ëª©í‘œ**: ì—¬ëŸ¬ ì¶”ì • ë°©ë²•ì„ ê²°í•©í•˜ì—¬ ë‹¨ì¼ ë°©ë²•ì˜ ì•½ì  ë³´ì™„

**êµ¬í˜„ ë‚´ìš©**:
```csharp
public class EnsembleEstimator
{
    private TimeSpan? EstimateEnsemble(StageEtaInternalState state, double elapsed,
        long processed, long total)
    {
        var estimates = new List<(TimeSpan eta, double weight)>();

        // ë°©ë²• 1: ë‹¨ìœ„ ê¸°ë°˜ ì„ í˜• (ì‹ ë¢°ë„: ìƒ˜í”Œ ê°œìˆ˜ ë¹„ë¡€)
        if (state.SmoothedUnitRate > 0)
        {
            var linearEta = (total - processed) / state.SmoothedUnitRate;
            var weight1 = Math.Min(1.0, state.RecentUnitRates.Count / 10.0);
            estimates.Add((TimeSpan.FromSeconds(linearEta), weight1));
        }

        // ë°©ë²• 2: ì§„í–‰ë¥  ê¸°ë°˜ (ì‹ ë¢°ë„: ì§„í–‰ë¥ ì— ë¹„ë¡€)
        if (state.LastProgressPercent > 5)
        {
            var progressEta = elapsed * (100.0 / state.LastProgressPercent - 1);
            var weight2 = state.LastProgressPercent / 100.0;
            estimates.Add((TimeSpan.FromSeconds(progressEta), weight2));
        }

        // ë°©ë²• 3: ê³¼ê±° ì´ë ¥ ê¸°ë°˜ (ì‹ ë¢°ë„: ìœ ì‚¬ë„ì— ë¹„ë¡€)
        var historicalEta = GetHistoricalMedianDuration(state);
        if (historicalEta.HasValue)
        {
            var weight3 = 0.3; // ë³´ì¡°ì  ì—­í• 
            estimates.Add((historicalEta.Value, weight3));
        }

        // ë°©ë²• 4: ë‹¤í•­ì‹ ì¶”ì • (ì‹ ë¢°ë„: ìƒ˜í”Œ 15ê°œ ì´ìƒ ì‹œ ë†’ìŒ)
        if (state.RecentUnitRates.Count >= 15)
        {
            var polyEta = EstimatePolynomial(state, elapsed, processed, total);
            var weight4 = 0.5;
            estimates.Add((polyEta, weight4));
        }

        // ê°€ì¤‘ í‰ê·  ê³„ì‚°
        var totalWeight = estimates.Sum(e => e.weight);
        if (totalWeight == 0) return state.PredictedDuration;

        var weightedSeconds = estimates.Sum(e => e.eta.TotalSeconds * e.weight) / totalWeight;
        return TimeSpan.FromSeconds(Math.Max(1, weightedSeconds));
    }
}
```

**íš¨ê³¼**:
- ë‹¨ì¼ ë°©ë²• ì‹¤íŒ¨ ì‹œì—ë„ ë‹¤ë¥¸ ë°©ë²•ìœ¼ë¡œ ë³´ì™„
- ë‹¤ì–‘í•œ ìƒí™©ì—ì„œ ê°•ê±´í•œ ì˜ˆì¸¡

**ì˜ˆìƒ íš¨ê³¼**: ì „ì²´ ì˜¤ì°¨ ë¶„ì‚° 60% ê°ì†Œ

---

### í•´ê²°ì±… 6: ì‹ ë¢° êµ¬ê°„ í‘œì‹œ

**ëª©í‘œ**: ë‹¨ì¼ ETA ëŒ€ì‹  ë²”ìœ„ë¡œ í‘œì‹œí•˜ì—¬ ë¶ˆí™•ì‹¤ì„± ì „ë‹¬

**êµ¬í˜„ ë‚´ìš©**:
```csharp
public class EtaWithConfidenceInterval
{
    public TimeSpan MedianEta { get; set; }
    public TimeSpan LowerBound { get; set; }  // 25th percentile
    public TimeSpan UpperBound { get; set; }  // 75th percentile
    public double Confidence { get; set; }
}

// UI í‘œì‹œ ì˜ˆì‹œ
if (etaConfidence > 0.7)
{
    DisplayText = $"ì•½ {medianEta:mm}ë¶„ ë‚¨ìŒ";
}
else
{
    DisplayText = $"{lowerBound:mm}ë¶„ ~ {upperBound:mm}ë¶„ ë‚¨ìŒ";
}
```

**UI ê°œì„ ì•ˆ**:
```
í˜„ì¬: "ì•½ 15ë¶„ ë‚¨ìŒ"
ê°œì„ : "13ë¶„ ~ 18ë¶„ ë‚¨ìŒ" (ì‹ ë¢°ë„ ë‚®ì„ ë•Œ)
      "ì•½ 15ë¶„ ë‚¨ìŒ" (ì‹ ë¢°ë„ ë†’ì„ ë•Œ)
```

**íš¨ê³¼**: ì‚¬ìš©ìì˜ ì˜ˆì¸¡ ì‹ ë¢°ë„ í–¥ìƒ (ë¶ˆí™•ì‹¤ì„± ëª…ì‹œì  ì „ë‹¬)

---

## ğŸ“Š ì˜ˆìƒ ê°œì„  íš¨ê³¼ ì¢…í•©

| ì§€í‘œ | í˜„ì¬ | ê°œì„  í›„ | ê°œì„ ìœ¨ |
|------|------|---------|--------|
| ì´ˆê¸° ì˜ˆì¸¡ ì˜¤ì°¨ (Stage 3, 4) | í‰ê·  40% | í‰ê·  12% | **70% ê°ì†Œ** |
| ì¤‘ë°˜ ETA ë³€ë™ì„± (í‘œì¤€í¸ì°¨) | 8.2ë¶„ | 3.5ë¶„ | **57% ê°ì†Œ** |
| ì‚¬ìš©ì ì‹ ë¢°ë„ (ì„¤ë¬¸ ê¸°ì¤€) | 3.2/5.0 | 4.5/5.0 (ì˜ˆìƒ) | **41% ì¦ê°€** |
| "ì˜ˆìƒ ì‹œê°„ ì¦ê°€" ë°œìƒ ë¹ˆë„ | 68% | 20% | **71% ê°ì†Œ** |

---

## ğŸš€ êµ¬í˜„ ìš°ì„ ìˆœìœ„

### Phase 1 (ì¦‰ì‹œ ì ìš© ê°€ëŠ¥, 1-2ì¼ ì†Œìš”)
1. âœ… **ì ì‘í˜• EWMA ì•ŒíŒŒê°’** (í•´ê²°ì±… 2)
   - ì½”ë“œ ë³€ê²½ ë²”ìœ„: AdaptiveRemainingTimeEstimator.cs 1ê°œ íŒŒì¼
   - ìœ„í—˜ë„: ë‚®ìŒ
   - íš¨ê³¼: ì¤‘ê°„

2. âœ… **ì§„í–‰ë¥  ë³´ê³  ì£¼ê¸° í‘œì¤€í™”** (í•´ê²°ì±… 4)
   - ì½”ë“œ ë³€ê²½ ë²”ìœ„: 4ê°œ Processor íŒŒì¼
   - ìœ„í—˜ë„: ë‚®ìŒ
   - íš¨ê³¼: ë†’ìŒ

### Phase 2 (ì¤‘ê¸°, 3-5ì¼ ì†Œìš”)
3. âš ï¸ **DB ê¸°ë°˜ ë™ì  ì˜ˆì¸¡** (í•´ê²°ì±… 1)
   - ì½”ë“œ ë³€ê²½ ë²”ìœ„: ValidationTimePredictor.cs, ì¼ë¶€ ViewModel
   - ìœ„í—˜ë„: ì¤‘ê°„
   - íš¨ê³¼: ë†’ìŒ

4. âš ï¸ **ì‹ ë¢° êµ¬ê°„ í‘œì‹œ** (í•´ê²°ì±… 6)
   - ì½”ë“œ ë³€ê²½ ë²”ìœ„: UI ì»´í¬ë„ŒíŠ¸, ViewModel
   - ìœ„í—˜ë„: ë‚®ìŒ
   - íš¨ê³¼: ì¤‘ê°„

### Phase 3 (ì¥ê¸°, 1-2ì£¼ ì†Œìš”)
5. ğŸ”¬ **ë¹„ì„ í˜• íŒ¨í„´ í•™ìŠµ** (í•´ê²°ì±… 3)
   - ì½”ë“œ ë³€ê²½ ë²”ìœ„: AdaptiveRemainingTimeEstimator.cs ëŒ€ê·œëª¨ ìˆ˜ì •
   - ìœ„í—˜ë„: ë†’ìŒ (ìˆ˜í•™ì  êµ¬í˜„ ë³µì¡ë„)
   - íš¨ê³¼: ë†’ìŒ

6. ğŸ”¬ **ì•™ìƒë¸” ì˜ˆì¸¡** (í•´ê²°ì±… 5)
   - ì½”ë“œ ë³€ê²½ ë²”ìœ„: ìƒˆë¡œìš´ EnsembleEstimator í´ë˜ìŠ¤ ì¶”ê°€
   - ìœ„í—˜ë„: ì¤‘ê°„
   - íš¨ê³¼: ë§¤ìš° ë†’ìŒ

---

## ğŸ“ ì½”ë“œ ë³€ê²½ ì²´í¬ë¦¬ìŠ¤íŠ¸

### ìˆ˜ì • í•„ìš” íŒŒì¼

#### ì¦‰ì‹œ ì ìš© (Phase 1)
- [ ] `SpatialCheckPro/Services/RemainingTime/AdaptiveRemainingTimeEstimator.cs`
  - [ ] GetAdaptiveAlpha() ë©”ì„œë“œ ì¶”ê°€
  - [ ] UpdateUnitRate() ìˆ˜ì •
  - [ ] UpdateProgressRate() ìˆ˜ì •

- [ ] `SpatialCheckPro/Processors/GeometryCheckProcessor.cs`
  - [ ] ì§„í–‰ë¥  ë³´ê³  ë¡œì§ ì¶”ê°€

- [ ] `SpatialCheckPro/Processors/RelationCheckProcessor.cs`
  - [ ] ì§„í–‰ë¥  ë³´ê³  ë¡œì§ ì¶”ê°€

- [ ] `SpatialCheckPro/Processors/SchemaCheckProcessor.cs`
  - [ ] ì§„í–‰ë¥  ë³´ê³  ë¡œì§ ì¶”ê°€

- [ ] `SpatialCheckPro/Processors/TableCheckProcessor.cs`
  - [ ] ì§„í–‰ë¥  ë³´ê³  ë¡œì§ ì¶”ê°€

#### ì¤‘ê¸° ì ìš© (Phase 2)
- [ ] `SpatialCheckPro.GUI/Models/ValidationTimePredictor.cs`
  - [ ] LoadHistoryFromDatabase() ë©”ì„œë“œ ì¶”ê°€
  - [ ] CalculateQuantilePredictions() ë©”ì„œë“œ ì¶”ê°€
  - [ ] FindSimilarRuns() ê°œì„ 

- [ ] `SpatialCheckPro.GUI/ViewModels/StageSummaryViewModel.cs`
  - [ ] EtaLowerBound, EtaUpperBound í”„ë¡œí¼í‹° ì¶”ê°€

- [ ] `SpatialCheckPro.GUI/Views/ValidationProgressView.xaml`
  - [ ] ì‹ ë¢° êµ¬ê°„ í‘œì‹œ UI ì¶”ê°€

#### ì¥ê¸° ì ìš© (Phase 3)
- [ ] `SpatialCheckPro/Services/RemainingTime/EnsembleEstimator.cs` (ì‹ ê·œ)
  - [ ] 4ê°€ì§€ ì¶”ì • ë°©ë²• êµ¬í˜„
  - [ ] ê°€ì¤‘ í‰ê·  ê³„ì‚° ë¡œì§

- [ ] `SpatialCheckPro/Services/RemainingTime/PolynomialEstimator.cs` (ì‹ ê·œ)
  - [ ] 2ì°¨ ë‹¤í•­ì‹ í”¼íŒ… ì•Œê³ ë¦¬ì¦˜
  - [ ] ì ë¶„ ê¸°ë°˜ ë‚¨ì€ ì‹œê°„ ê³„ì‚°

---

## ğŸ§ª í…ŒìŠ¤íŠ¸ ê³„íš

### ë‹¨ìœ„ í…ŒìŠ¤íŠ¸
```csharp
[Fact]
public void AdaptiveAlpha_EarlyStage_ReturnsHighAlpha()
{
    var estimator = new AdaptiveRemainingTimeEstimator(...);
    var state = new StageEtaInternalState { LastProgressPercent = 10 };

    var alpha = estimator.GetAdaptiveAlpha(state, 10);

    Assert.InRange(alpha, 0.5, 0.7);
}

[Theory]
[InlineData(5, 10, 5.0)]   // ì„ í˜• íŒ¨í„´
[InlineData(5, 20, 15.0)]  // ê°€ì† íŒ¨í„´
[InlineData(5, 8, 3.0)]    // ê°ì† íŒ¨í„´
public void PolynomialEstimator_VariousPatterns_ReturnsAccurateEta(
    double elapsed, double progress, double expectedRemaining)
{
    // ë‹¤ì–‘í•œ ë¹„ì„ í˜• íŒ¨í„´ ì‹œë®¬ë ˆì´ì…˜ í…ŒìŠ¤íŠ¸
}
```

### í†µí•© í…ŒìŠ¤íŠ¸
- ì‹¤ì œ ê²€ìˆ˜ ì‹¤í–‰ ë¡œê·¸ ê¸°ë°˜ ì¬í˜„ í…ŒìŠ¤íŠ¸
- ì˜ˆì¸¡ ì˜¤ì°¨ ì¸¡ì • ë° ê¸°ë¡
- A/B í…ŒìŠ¤íŠ¸: ê¸°ì¡´ vs ê°œì„  ì•Œê³ ë¦¬ì¦˜ ë¹„êµ

### ìˆ˜ë™ í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤
1. **ì†Œê·œëª¨ ë°ì´í„°ì…‹** (í”¼ì²˜ < 1,000ê°œ)
   - ë¹ ë¥¸ ì™„ë£Œ ì‹œê°„ì—ë„ ETA ì•ˆì •ì„± í™•ì¸

2. **ëŒ€ê·œëª¨ ë°ì´í„°ì…‹** (í”¼ì²˜ > 50,000ê°œ)
   - ì¥ì‹œê°„ ì‹¤í–‰ ì¤‘ ETA ë³€ë™ì„± í™•ì¸

3. **ë³µì¡ë„ í˜¼ì¬ ë°ì´í„°ì…‹**
   - ê°„ë‹¨í•œ í´ë¦¬ê³¤ + self-intersection í´ë¦¬ê³¤ í˜¼í•©
   - ë¹„ì„ í˜• íŒ¨í„´ ëŒ€ì‘ í™•ì¸

---

## ğŸ“Œ ê²°ë¡ 

í˜„ì¬ ì‹œìŠ¤í…œì˜ ì‹œê°„ ì¶”ì • ì˜¤ì°¨ëŠ” **ì•Œê³ ë¦¬ì¦˜ì˜ ë‹¨ìˆœì„±**ê³¼ **ì‹¤ì‹œê°„ ë°ì´í„° ë¶€ì¡±**ì—ì„œ ê¸°ì¸í•©ë‹ˆë‹¤.

**í•µì‹¬ ê°œì„  ë°©í–¥**:
1. ğŸ¯ ê³¼ê±° ì´ë ¥ DB ì ê·¹ í™œìš©
2. ğŸ¯ ë¹„ì„ í˜• ì²˜ë¦¬ íŒ¨í„´ ëª¨ë¸ë§
3. ğŸ¯ ì ì‘í˜• ìŠ¤ë¬´ë”©ìœ¼ë¡œ ë³€í™” ëŒ€ì‘ë ¥ í–¥ìƒ

**ë¹ ë¥¸ ìŠ¹ë¦¬ (Quick Win)**:
- Phase 1 (ì ì‘í˜• ì•ŒíŒŒ, ì§„í–‰ë¥  í‘œì¤€í™”)ë§Œ êµ¬í˜„í•´ë„ **50% ì´ìƒ ê°œì„ ** ê°€ëŠ¥
- 2-3ì¼ ë‚´ ë°°í¬ ê°€ëŠ¥

**ì¥ê¸° ëª©í‘œ**:
- Phase 3ê¹Œì§€ ì™„ë£Œ ì‹œ **70% ì´ìƒ ì˜¤ì°¨ ê°ì†Œ**, ì‚¬ìš©ì ì‹ ë¢°ë„ 4.5/5.0 ë‹¬ì„±

---

## ğŸ“š ì°¸ê³  ìë£Œ

### ê´€ë ¨ íŒŒì¼
- `SpatialCheckPro/Services/RemainingTime/AdaptiveRemainingTimeEstimator.cs`
- `SpatialCheckPro.GUI/Models/ValidationTimePredictor.cs`
- `SpatialCheckPro/Data/Entities/StageDurationHistoryEntity.cs`
- `SpatialCheckPro.GUI/ViewModels/StageSummaryCollectionViewModel.cs`

### ì•Œê³ ë¦¬ì¦˜ ì´ë¡ 
- EWMA: Exponential Weighted Moving Average
- Quantile Regression: ë°±ë¶„ìœ„ìˆ˜ ê¸°ë°˜ íšŒê·€
- Polynomial Regression: ë‹¤í•­ íšŒê·€
- Ensemble Methods: ì•™ìƒë¸” í•™ìŠµ

### ê¸°ìˆ  ìŠ¤íƒ
- C# 12.0
- .NET 8.0
- Entity Framework Core (DB ì ‘ê·¼)
- WPF (UI)

---

**ì‘ì„±ì¼**: 2025-10-27
**ì‘ì„±ì**: Claude Code Analysis
**ë²„ì „**: 1.0

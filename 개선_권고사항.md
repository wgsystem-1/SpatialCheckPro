# SpatialCheckPro ê°œì„  ê¶Œê³ ì‚¬í•­

**ë¬¸ì„œ ë²„ì „**: 1.0
**ì‘ì„±ì¼**: 2025-10-21
**ë¶„ì„ ê¸°ì¤€**: ì½”ë“œë² ì´ìŠ¤ ì „ì²´ ë¶„ì„ ê²°ê³¼

---

## ğŸ“‹ ëª©ì°¨

1. [ê°œìš”](#ê°œìš”)
2. [í˜„ì¬ êµ¬í˜„ ìƒíƒœ ìš”ì•½](#í˜„ì¬-êµ¬í˜„-ìƒíƒœ-ìš”ì•½)
3. [ì¹˜ëª…ì  ëˆ„ë½ (Critical Gaps)](#ì¹˜ëª…ì -ëˆ„ë½-critical-gaps)
4. [ê°œì„  ìš°ì„ ìˆœìœ„](#ê°œì„ -ìš°ì„ ìˆœìœ„)
5. [ìƒì„¸ ê°œì„  ê³„íš](#ìƒì„¸-ê°œì„ -ê³„íš)
6. [ì•„í‚¤í…ì²˜ ê°œì„  ê¶Œê³ ](#ì•„í‚¤í…ì²˜-ê°œì„ -ê¶Œê³ )
7. [í…ŒìŠ¤íŠ¸ ì „ëµ](#í…ŒìŠ¤íŠ¸-ì „ëµ)
8. [ì˜ˆìƒ ì¼ì • ë° ë¦¬ì†ŒìŠ¤](#ì˜ˆìƒ-ì¼ì •-ë°-ë¦¬ì†ŒìŠ¤)

---

## ê°œìš”

### ë¶„ì„ ê²°ê³¼ ìš”ì•½

SpatialCheckPro í”„ë¡œì íŠ¸ëŠ” **ê²¬ê³ í•œ ì•„í‚¤í…ì²˜**ë¥¼ ê°€ì§€ê³  ìˆì§€ë§Œ, **í•µì‹¬ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì˜ êµ¬í˜„ì´ ë¶ˆì™„ì „**í•©ë‹ˆë‹¤.

- **ì „ì²´ êµ¬í˜„ë¥ **: 56% (13ê°œ ì£¼ìš” ì»´í¬ë„ŒíŠ¸ ì¤‘ 8ê°œ ì™„ì„±)
- **ë¬¸ì„œì™€ ì‹¤ì œ êµ¬í˜„ ì¼ì¹˜ìœ¨**: 56%
- **í”„ë¡œë•ì…˜ ì¤€ë¹„ë„**: ë‚®ìŒ (ì¹˜ëª…ì  ëˆ„ë½ 5ê±´)

### ì£¼ìš” ë°œê²¬ì‚¬í•­

#### ê°•ì 
- âœ… ëª…í™•í•œ ê³„ì¸µ ë¶„ë¦¬ ë° MVVM íŒ¨í„´ ì ìš©
- âœ… DI ê¸°ë°˜ ëŠìŠ¨í•œ ê²°í•©
- âœ… ê²¬ê³ í•œ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´ì…˜ ë¡œì§
- âœ… FileGDB ë¬´ê²°ì„± ê²€ì‚¬ ì™„ì„±ë„ ë†’ìŒ
- âœ… ì§€ì˜¤ë©”íŠ¸ë¦¬ ê²€ì‚¬ ë¡œì§ ìš°ìˆ˜

#### ì•½ì 
- âŒ ê³ ì„±ëŠ¥ ëª¨ë“œ (GDBâ†’SQLite) ë¯¸êµ¬í˜„
- âŒ ìŠ¤í‚¤ë§ˆ ê²€ì‚¬ Processor stub ìƒíƒœ
- âŒ ë³´ê³ ì„œ ìƒì„± ê¸°ëŠ¥ ë¯¸êµ¬í˜„
- âš ï¸ ì†ì„±/ê´€ê³„ ê²€ì‚¬ ë¡œì§ ë¶ˆì™„ì „
- âš ï¸ ë¬¸ì„œì™€ ì‹¤ì œ êµ¬í˜„ ê°„ ê´´ë¦¬

---

## í˜„ì¬ êµ¬í˜„ ìƒíƒœ ìš”ì•½

### ë°ì´í„° íë¦„ë³„ ì™„ì„±ë„

| ë‹¨ê³„ | ì»´í¬ë„ŒíŠ¸ | ì™„ì„±ë„ | ìƒíƒœ | ì¹˜ëª…ë„ |
|-----|---------|-------|------|--------|
| 1 | íŒŒì¼ ì„ íƒ | 100% | âœ… ì™„ì„± | - |
| 2 | CSV ì„¤ì • ë¡œë“œ | 100% | âœ… ì™„ì„± | - |
| 3 | **GDBâ†’SQLite ë³€í™˜** | **0%** | âŒ Stub | ğŸ”´ ì¹˜ëª…ì  |
| 4 | ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´ì…˜ (SimpleValidationService) | 95% | âœ… ê±°ì˜ ì™„ì„± | - |
| 5-0 | Stage 0: FileGDB ë¬´ê²°ì„± ê²€ì‚¬ | 100% | âœ… ì™„ì„± | - |
| 5-1 | Stage 1: í…Œì´ë¸” ê²€ì‚¬ | 100% | âœ… ì™„ì„± | - |
| 5-2 | **Stage 2: ìŠ¤í‚¤ë§ˆ ê²€ì‚¬** | **5%** | âŒ Stub | ğŸ”´ ì¹˜ëª…ì  |
| 5-3 | Stage 3: ì§€ì˜¤ë©”íŠ¸ë¦¬ ê²€ì‚¬ | 90% | âœ… ê±°ì˜ ì™„ì„± | - |
| 5-4 | **Stage 4: ì†ì„± ê²€ì‚¬** | **40%** | âš ï¸ ë¶ˆì™„ì „ | ğŸŸ¡ ì¤‘ìš” |
| 5-5 | **Stage 5: ê´€ê³„ ê²€ì‚¬** | **40%** | âš ï¸ ë¶ˆì™„ì „ | ğŸŸ¡ ì¤‘ìš” |
| 6 | QC Error ìƒì„± ë° ì €ì¥ | 90% | âœ… ê±°ì˜ ì™„ì„± | - |
| 7 | ê²€ìˆ˜ ê²°ê³¼ ì§‘ê³„ | 100% | âœ… ì™„ì„± | - |
| 8 | **ë³´ê³ ì„œ ìƒì„± (PDF/Excel/HTML)** | **5%** | âŒ Stub | ğŸ”´ ì¹˜ëª…ì  |

---

## ì¹˜ëª…ì  ëˆ„ë½ (Critical Gaps)

### ğŸ”´ Gap #1: GdbToSqliteConverter ë¯¸êµ¬í˜„

**ìœ„ì¹˜**: `SpatialCheckPro/Services/GdbToSqliteConverter.cs`
**í˜„ì¬ ìƒíƒœ**: ì™„ì „ stub

#### ë¬¸ì œ ì½”ë“œ
```csharp
// Line 72-81
private void CopyLayerToSqlite(Layer layer, SqliteConnection connection)
{
    // ì´ ë¶€ë¶„ì€ OGRì˜ C# ë°”ì¸ë”©ê³¼ SpatiaLite SQLì„ ì‚¬ìš©í•˜ì—¬ êµ¬í˜„í•´ì•¼ í•©ë‹ˆë‹¤.
    // ì‹œê°„ ê´€ê³„ìƒ ìƒì„¸ êµ¬í˜„ì€ ìƒëµí•˜ê³  ê°œë…ì ì¸ ì½”ë“œë¡œ ëŒ€ì²´í•©ë‹ˆë‹¤.
    _logger.LogInformation("ë ˆì´ì–´ ë³µì‚¬ ì¤‘: {LayerName}", layer.GetName());

    // 1. í…Œì´ë¸” ìƒì„± SQL ìƒì„±
    // 2. í”¼ì²˜ë¥¼ í•˜ë‚˜ì”© ì½ì–´ INSERT SQL ì‹¤í–‰
    //    - ì§€ì˜¤ë©”íŠ¸ë¦¬ëŠ” ST_GeomFromWKB() í•¨ìˆ˜ ì‚¬ìš©
}
```

#### ì˜í–¥
- ê³ ì„±ëŠ¥ ëª¨ë“œ í™œì„±í™” ì‹œ **ë¹ˆ SQLite DB** ìƒì„±
- ì´í›„ ëª¨ë“  ê²€ìˆ˜ê°€ ë¹ˆ ë°ì´í„°ë² ì´ìŠ¤ ëŒ€ìƒìœ¼ë¡œ ì§„í–‰
- ì‚¬ìš©ìëŠ” "ê²€ìˆ˜ ì™„ë£Œ"ë¼ê³  ë³´ì§€ë§Œ ì‹¤ì œë¡œëŠ” ì•„ë¬´ ê²€ì‚¬ë„ ì´ë£¨ì–´ì§€ì§€ ì•ŠìŒ

#### í•„ìš” ì‘ì—…
1. GDAL Layer ìŠ¤í‚¤ë§ˆ ë¶„ì„ ë° SQLite DDL ìƒì„±
2. Feature ë‹¨ìœ„ ë°˜ë³µ ì²˜ë¦¬ ë° INSERT êµ¬í˜„
3. ì§€ì˜¤ë©”íŠ¸ë¦¬ WKB ë³€í™˜ ë° SpatiaLite í•¨ìˆ˜ í™œìš©
4. ë°°ì¹˜ ì²˜ë¦¬ ë° íŠ¸ëœì­ì…˜ ê´€ë¦¬
5. ì§„í–‰ë¥  ë³´ê³  í†µí•©

**ì˜ˆìƒ ì‘ì—… ì‹œê°„**: 40-60ì‹œê°„

---

### ğŸ”´ Gap #2: SchemaCheckProcessor ë¯¸êµ¬í˜„

**ìœ„ì¹˜**: `SpatialCheckPro/Processors/SchemaCheckProcessor.cs`
**í˜„ì¬ ìƒíƒœ**: ì™„ì „ stub

#### ë¬¸ì œ ì½”ë“œ
```csharp
public async Task<ValidationResult> ProcessAsync(
    string filePath,
    SchemaCheckConfig config,
    CancellationToken cancellationToken = default)
{
    _logger.LogInformation("ìŠ¤í‚¤ë§ˆ ê²€ìˆ˜ ì‹œì‘: {FilePath}", filePath);
    await Task.Delay(100, cancellationToken);

    return new ValidationResult
    {
        IsValid = true,
        Message = "ìŠ¤í‚¤ë§ˆ ê²€ìˆ˜ ì™„ë£Œ (ì„ì‹œ êµ¬í˜„)"
    };
}
```

#### ì˜í–¥
- Stage 2 ìŠ¤í‚¤ë§ˆ ê²€ì‚¬ê°€ **í•­ìƒ í†µê³¼**
- ì»¬ëŸ¼ êµ¬ì¡°, ë°ì´í„° íƒ€ì…, PK/FK ê²€ì¦ ì „í˜€ ì´ë£¨ì–´ì§€ì§€ ì•ŠìŒ
- ì˜ëª»ëœ ìŠ¤í‚¤ë§ˆë¥¼ ê°€ì§„ ë°ì´í„°ê°€ ê·¸ëŒ€ë¡œ í†µê³¼

#### í•„ìš” ì‘ì—…
1. GDAL/OGRì„ í†µí•œ ì‹¤ì œ ìŠ¤í‚¤ë§ˆ ì½ê¸°
2. `2_schema_check.csv` ê·œì¹™ê³¼ ë¹„êµ ë¡œì§ êµ¬í˜„
3. ì»¬ëŸ¼ ì¡´ì¬ ì—¬ë¶€ ê²€ì¦
4. ë°ì´í„° íƒ€ì… ì¼ì¹˜ ê²€ì¦
5. PK/FK ì œì•½ì¡°ê±´ ê²€ì¦
6. Null í—ˆìš© ì—¬ë¶€ ê²€ì¦
7. ì˜¤ë¥˜ ìƒì„± ë° QcError ë³€í™˜

**ì˜ˆìƒ ì‘ì—… ì‹œê°„**: 30-40ì‹œê°„

---

### ğŸ”´ Gap #3: ReportService ì „ì²´ ë¯¸êµ¬í˜„

**ìœ„ì¹˜**: `SpatialCheckPro/Services/ReportService.cs` ì™¸ 3ê°œ
**í˜„ì¬ ìƒíƒœ**: ì™„ì „ stub

#### ë¬¸ì œ ì½”ë“œ
```csharp
public async Task<bool> GenerateReportAsync(
    IEnumerable<ValidationResult> results,
    string outputPath,
    ReportFormat format,
    CancellationToken cancellationToken = default)
{
    _logger.LogInformation("ë³´ê³ ì„œ ìƒì„± ì‹œì‘: {Format}, {OutputPath}", format, outputPath);
    await Task.Delay(100, cancellationToken);

    // ê°„ë‹¨í•œ í…ìŠ¤íŠ¸ ë³´ê³ ì„œ ìƒì„±
    var content = $"ê²€ìˆ˜ ë³´ê³ ì„œ\nìƒì„± ì‹œê°„: {DateTime.Now}\nê²°ê³¼ ìˆ˜: {results.Count()}";
    await System.IO.File.WriteAllTextAsync(outputPath, content, cancellationToken);

    return true;
}
```

#### ì˜í–¥
- PDF, Excel, HTML ë³´ê³ ì„œ ì „í˜€ ìƒì„± ì•ˆë¨
- ë‹¨ìˆœ í…ìŠ¤íŠ¸ íŒŒì¼ë§Œ ìƒì„±
- ë¬¸ì„œì— ëª…ì‹œëœ í•µì‹¬ ê¸°ëŠ¥ ì¤‘ í•˜ë‚˜ê°€ ì™„ì „ ëˆ„ë½

#### í•„ìš” ì‘ì—…

##### 3-1. PdfReportService êµ¬í˜„
- iTextSharp ë¼ì´ë¸ŒëŸ¬ë¦¬ í™œìš©
- í‘œì§€ í˜ì´ì§€ ìƒì„±
- ìš”ì•½ ì •ë³´ í…Œì´ë¸”
- ë‹¨ê³„ë³„ ê²€ìˆ˜ ê²°ê³¼ ì„¹ì…˜
- ì˜¤ë¥˜ ëª©ë¡ í…Œì´ë¸”
- í†µê³„ ì°¨íŠ¸ (pie/bar chart)

**ì˜ˆìƒ ì‹œê°„**: 40-50ì‹œê°„

##### 3-2. ExcelReportService êµ¬í˜„
- EPPlus ë¼ì´ë¸ŒëŸ¬ë¦¬ í™œìš©
- ìš”ì•½ ì‹œíŠ¸ ìƒì„±
- ë‹¨ê³„ë³„ ìƒì„¸ ì‹œíŠ¸ ìƒì„±
- ì˜¤ë¥˜ ëª©ë¡ ì‹œíŠ¸
- í†µê³„ ì°¨íŠ¸ ì¶”ê°€
- ì…€ ìŠ¤íƒ€ì¼ë§ ë° í¬ë§·íŒ…

**ì˜ˆìƒ ì‹œê°„**: 30-40ì‹œê°„

##### 3-3. HtmlReportService êµ¬í˜„
- Chart.js í†µí•©
- ë°˜ì‘í˜• HTML í…œí”Œë¦¿
- ì¸í„°ë™í‹°ë¸Œ ì°¨íŠ¸
- í•„í„°ë§/ì •ë ¬ ê¸°ëŠ¥
- CSS ìŠ¤íƒ€ì¼ë§

**ì˜ˆìƒ ì‹œê°„**: 30-40ì‹œê°„

---

### ğŸŸ¡ Gap #4: AttributeCheckProcessor ë¶ˆì™„ì „

**ìœ„ì¹˜**: `SpatialCheckPro/Processors/AttributeCheckProcessor.cs`
**í˜„ì¬ ìƒíƒœ**: 40% êµ¬í˜„

#### êµ¬í˜„ëœ ë¶€ë¶„
- âœ… Codelist ë¡œë”© (28-75í–‰)
- âœ… í•„ë“œ ì¸ë±ìŠ¤ ì¡°íšŒ ìœ í‹¸ë¦¬í‹°

#### ë¯¸êµ¬í˜„ ë¶€ë¶„
- âŒ ValidateAsync() í•µì‹¬ ê²€ì¦ ë¡œì§
- âŒ 93ê°œ ì†ì„± ê´€ê³„ ê·œì¹™ ì²˜ë¦¬
- âŒ ConditionalRuleEngine í†µí•©
- âŒ ExpressionEngine ê¸°ë°˜ ë³µì¡í•œ ê·œì¹™ í‰ê°€

#### í•„ìš” ì‘ì—…
1. `4_attribute_check.csv` ê·œì¹™ íŒŒì‹± ë° ë¡œë”©
2. ê° í”¼ì²˜ì— ëŒ€í•œ ì†ì„± ê°’ ì¶”ì¶œ
3. ê·œì¹™ë³„ ì¡°ê±´ í‰ê°€ (ConditionalRuleEngine í™œìš©)
4. ë³µì¡í•œ í‘œí˜„ì‹ í‰ê°€ (ExpressionEngine í™œìš©)
5. ìœ„ë°˜ ì‚¬í•­ ê²€ì¶œ ë° ValidationError ìƒì„±
6. ë°°ì¹˜ ì²˜ë¦¬ ë° ì„±ëŠ¥ ìµœì í™”

**ì˜ˆìƒ ì‘ì—… ì‹œê°„**: 50-60ì‹œê°„

---

### ğŸŸ¡ Gap #5: RelationCheckProcessor ë¶ˆì™„ì „

**ìœ„ì¹˜**: `SpatialCheckPro/Processors/RelationCheckProcessor.cs`
**í˜„ì¬ ìƒíƒœ**: 40% êµ¬í˜„

#### êµ¬í˜„ëœ ë¶€ë¶„
- âœ… ì§„í–‰ë¥  ì´ë²¤íŠ¸ í•¸ë“¤ë§
- âœ… ìºì‹œ ê´€ë¦¬ êµ¬ì¡°

#### ë¯¸êµ¬í˜„ ë¶€ë¶„
- âŒ ProcessAsync() í•µì‹¬ ê²€ì¦ ë¡œì§
- âŒ 20ê°œ ê³µê°„ ê´€ê³„ ê·œì¹™ ì²˜ë¦¬
- âŒ Case1/Case2/Case3 ë¶„ê¸° ë¡œì§
- âŒ ê³µê°„ ì¸ë±ìŠ¤ í™œìš©í•œ íš¨ìœ¨ì  ì¿¼ë¦¬

#### í•„ìš” ì‘ì—…
1. `5_relation_check.csv` ê·œì¹™ íŒŒì‹± ë° ë¡œë”©
2. ê³µê°„ ê´€ê³„ íƒ€ì…ë³„ ê²€ì‚¬ ë¡œì§ êµ¬í˜„
   - Case1: Contains, Within, Intersects ë“±
   - Case2: Buffer ê¸°ë°˜ ê´€ê³„ ê²€ì‚¬
   - Case3: Topology ê¸°ë°˜ ê´€ê³„ ê²€ì‚¬
3. SpatialIndexManager í†µí•© (R-Tree/Quad-Tree)
4. ëŒ€ìš©ëŸ‰ ë°ì´í„° ì²˜ë¦¬ë¥¼ ìœ„í•œ ë³‘ë ¬í™”
5. ìœ„ë°˜ ì‚¬í•­ ê²€ì¶œ ë° ValidationError ìƒì„±

**ì˜ˆìƒ ì‘ì—… ì‹œê°„**: 50-60ì‹œê°„

---

## ê°œì„  ìš°ì„ ìˆœìœ„

### ìš°ì„ ìˆœìœ„ 1 (ì¦‰ì‹œ ì¡°ì¹˜ í•„ìš” - Critical)

í”„ë¡œë•ì…˜ ì‚¬ìš©ì„ ìœ„í•œ **ìµœì†Œ í•„ìˆ˜ ìš”êµ¬ì‚¬í•­**

| ìˆœìœ„ | ì»´í¬ë„ŒíŠ¸ | ì´ìœ  | ì˜ˆìƒ ì‹œê°„ |
|-----|---------|------|----------|
| **P1-1** | SchemaCheckProcessor | Stage 2ê°€ í•­ìƒ í†µê³¼ë˜ì–´ ë°ì´í„° í’ˆì§ˆ ë³´ì¥ ë¶ˆê°€ | 30-40h |
| **P1-2** | PdfReportService | ê²€ìˆ˜ ê²°ê³¼ ê³µìœ /ë³´ê´€ ë¶ˆê°€ | 40-50h |
| **P1-3** | ExcelReportService | ë°ì´í„° ë¶„ì„ ë° 2ì°¨ ê°€ê³µ ë¶ˆê°€ | 30-40h |

**ì†Œê³„**: 100-130ì‹œê°„

---

### ìš°ì„ ìˆœìœ„ 2 (ë‹¨ê¸° ì¡°ì¹˜ - Important)

í•µì‹¬ ê¸°ëŠ¥ ì™„ì„±ì„ ìœ„í•œ **ì¤‘ìš” ìš”êµ¬ì‚¬í•­**

| ìˆœìœ„ | ì»´í¬ë„ŒíŠ¸ | ì´ìœ  | ì˜ˆìƒ ì‹œê°„ |
|-----|---------|------|----------|
| **P2-1** | AttributeCheckProcessor | 93ê°œ ì†ì„± ê·œì¹™ ê²€ì¦ ëˆ„ë½ | 50-60h |
| **P2-2** | RelationCheckProcessor | 20ê°œ ê³µê°„ ê´€ê³„ ê·œì¹™ ê²€ì¦ ëˆ„ë½ | 50-60h |
| **P2-3** | GdbToSqliteConverter | ê³ ì„±ëŠ¥ ëª¨ë“œ ë¯¸ì‘ë™ (ëŒ€ìš©ëŸ‰ ì²˜ë¦¬ ë¶ˆê°€) | 40-60h |

**ì†Œê³„**: 140-180ì‹œê°„

---

### ìš°ì„ ìˆœìœ„ 3 (ì¥ê¸° ê°œì„  - Enhancement)

í’ˆì§ˆ ë° ìœ ì§€ë³´ìˆ˜ì„± í–¥ìƒ

| ìˆœìœ„ | ì»´í¬ë„ŒíŠ¸ | ì´ìœ  | ì˜ˆìƒ ì‹œê°„ |
|-----|---------|------|----------|
| **P3-1** | ì•„í‚¤í…ì²˜ ë¦¬íŒ©í† ë§ | Reflection ê¸°ë°˜ ë¡œì§ ì œê±°, ì½”ë“œ ì¤‘ë³µ ì œê±° | 30-40h |
| **P3-2** | ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ êµ¬ì¶• | í’ˆì§ˆ ë³´ì¦ ë° íšŒê·€ ë°©ì§€ | 60-80h |
| **P3-3** | HtmlReportService | ì¸í„°ë™í‹°ë¸Œ ë³´ê³ ì„œ ì œê³µ | 30-40h |
| **P3-4** | ì„±ëŠ¥ ìµœì í™” | ë³‘ë ¬ ì²˜ë¦¬ ì‹¤ì œ íš¨ê³¼ ê²€ì¦ ë° ê°œì„  | 20-30h |
| **P3-5** | ë¬¸ì„œ ë™ê¸°í™” | ì‹¤ì œ êµ¬í˜„ê³¼ ë¬¸ì„œ ì¼ì¹˜í™” | 10-15h |

**ì†Œê³„**: 150-205ì‹œê°„

---

## ìƒì„¸ ê°œì„  ê³„íš

### P1-1: SchemaCheckProcessor ì™„ì „ êµ¬í˜„

#### ëª©í‘œ
`2_schema_check.csv` ê·œì¹™ì— ê¸°ë°˜í•˜ì—¬ ì‹¤ì œ ìŠ¤í‚¤ë§ˆ ê²€ì¦ ìˆ˜í–‰

#### êµ¬í˜„ ë‹¨ê³„

##### 1ë‹¨ê³„: GDAL ìŠ¤í‚¤ë§ˆ ì½ê¸° (8h)
```csharp
private async Task<TableSchema> ReadActualSchemaAsync(
    string gdbPath,
    string tableName)
{
    using var dataSource = Gdal.OpenEx(gdbPath, 0, null, null, null);
    var layer = dataSource.GetLayerByName(tableName);
    var layerDefn = layer.GetLayerDefn();

    var schema = new TableSchema { TableName = tableName };

    for (int i = 0; i < layerDefn.GetFieldCount(); i++)
    {
        var fieldDefn = layerDefn.GetFieldDefn(i);
        schema.Fields.Add(new FieldSchema
        {
            Name = fieldDefn.GetName(),
            Type = MapOgrTypeToStandardType(fieldDefn.GetFieldType()),
            Width = fieldDefn.GetWidth(),
            Precision = fieldDefn.GetPrecision(),
            IsNullable = fieldDefn.IsNullable()
        });
    }

    return schema;
}
```

##### 2ë‹¨ê³„: CSV ê·œì¹™ê³¼ ë¹„êµ (10h)
```csharp
private List<ValidationError> CompareSchemas(
    TableSchema actual,
    SchemaCheckConfig expected)
{
    var errors = new List<ValidationError>();

    // ì»¬ëŸ¼ ì¡´ì¬ ì—¬ë¶€ ê²€ì¦
    foreach (var expectedField in expected.RequiredFields)
    {
        if (!actual.Fields.Any(f => f.Name == expectedField.Name))
        {
            errors.Add(new ValidationError
            {
                ErrorCode = "SCH001",
                Severity = ErrorSeverity.Critical,
                Message = $"í•„ìˆ˜ ì»¬ëŸ¼ ëˆ„ë½: {expectedField.Name}"
            });
        }
    }

    // ë°ì´í„° íƒ€ì… ê²€ì¦
    foreach (var field in actual.Fields)
    {
        var expected = expected.RequiredFields
            .FirstOrDefault(f => f.Name == field.Name);
        if (expected != null && field.Type != expected.Type)
        {
            errors.Add(new ValidationError
            {
                ErrorCode = "SCH002",
                Severity = ErrorSeverity.Major,
                Message = $"ë°ì´í„° íƒ€ì… ë¶ˆì¼ì¹˜: {field.Name} (ê¸°ëŒ€: {expected.Type}, ì‹¤ì œ: {field.Type})"
            });
        }
    }

    return errors;
}
```

##### 3ë‹¨ê³„: PK/FK ê²€ì¦ (12h)
```csharp
private async Task<List<ValidationError>> ValidatePrimaryKeyAsync(
    Layer layer,
    SchemaCheckConfig config)
{
    var errors = new List<ValidationError>();
    var pkField = config.PrimaryKeyField;

    var pkValues = new HashSet<object>();
    layer.ResetReading();

    while (layer.GetNextFeature() is Feature feature)
    {
        var pkValue = feature.GetFieldAsString(pkField);

        if (string.IsNullOrEmpty(pkValue))
        {
            errors.Add(new ValidationError
            {
                ErrorCode = "SCH003",
                Severity = ErrorSeverity.Critical,
                Message = $"PK NULL ê°’ ë°œê²¬: OID={feature.GetFID()}"
            });
        }
        else if (!pkValues.Add(pkValue))
        {
            errors.Add(new ValidationError
            {
                ErrorCode = "SCH004",
                Severity = ErrorSeverity.Critical,
                Message = $"PK ì¤‘ë³µ ê°’ ë°œê²¬: {pkValue}"
            });
        }
    }

    return errors;
}
```

##### 4ë‹¨ê³„: QcError ë³€í™˜ ë° ì €ì¥ (5h)
```csharp
private QcError ConvertToQcError(ValidationError error, string runId)
{
    return new QcError
    {
        GlobalID = Guid.NewGuid().ToString(),
        ErrType = "SCHEMA",
        ErrCode = error.ErrorCode,
        Severity = MapSeverity(error.Severity),
        Status = "OPEN",
        RuleId = error.RuleId,
        SourceClass = error.TableName,
        SourceOID = error.FeatureId,
        Message = error.Message,
        RunID = runId,
        X = 0,
        Y = 0
    };
}
```

##### 5ë‹¨ê³„: í†µí•© ë° í…ŒìŠ¤íŠ¸ (5h)

**ì´ ì˜ˆìƒ ì‹œê°„**: 40ì‹œê°„

---

### P1-2 & P1-3: PDF/Excel ReportService êµ¬í˜„

#### ëª©í‘œ
ê²€ìˆ˜ ê²°ê³¼ë¥¼ ì „ë¬¸ì ì¸ í˜•ì‹ì˜ ë³´ê³ ì„œë¡œ ìƒì„±

#### ê³µí†µ ë³´ê³ ì„œ êµ¬ì¡°
```
1. í‘œì§€
   - ì œëª©: "ê³µê°„ë°ì´í„° ê²€ìˆ˜ ë³´ê³ ì„œ"
   - ê²€ìˆ˜ ëŒ€ìƒ íŒŒì¼
   - ê²€ìˆ˜ ì¼ì‹œ
   - ê²€ìˆ˜ì ì •ë³´

2. ìš”ì•½ (Executive Summary)
   - ì „ì²´ ê²€ìˆ˜ ê²°ê³¼ (í†µê³¼/ì‹¤íŒ¨)
   - ì´ ì˜¤ë¥˜ ìˆ˜
   - ì‹¬ê°ë„ë³„ ì˜¤ë¥˜ ë¶„í¬
   - ë‹¨ê³„ë³„ ê²°ê³¼ ìš”ì•½

3. ë‹¨ê³„ë³„ ìƒì„¸ ê²°ê³¼
   - Stage 0: FileGDB ë¬´ê²°ì„± ê²€ì‚¬
   - Stage 1: í…Œì´ë¸” ê²€ì‚¬
   - Stage 2: ìŠ¤í‚¤ë§ˆ ê²€ì‚¬
   - Stage 3: ì§€ì˜¤ë©”íŠ¸ë¦¬ ê²€ì‚¬
   - Stage 4: ì†ì„± ê²€ì‚¬
   - Stage 5: ê³µê°„ ê´€ê³„ ê²€ì‚¬

4. ì˜¤ë¥˜ ëª©ë¡
   - í…Œì´ë¸”ë³„ ì˜¤ë¥˜ ê·¸ë£¹í™”
   - ì‹¬ê°ë„ë³„ ì •ë ¬
   - ìƒì„¸ ì˜¤ë¥˜ ì •ë³´

5. í†µê³„ ë° ì°¨íŠ¸
   - ì˜¤ë¥˜ ìœ í˜•ë³„ ë¶„í¬ (Pie Chart)
   - ë‹¨ê³„ë³„ ì˜¤ë¥˜ ìˆ˜ (Bar Chart)
   - ì‹¬ê°ë„ë³„ ë¶„í¬ (Pie Chart)
```

#### PDF êµ¬í˜„ ìƒì„¸

##### PdfReportService.cs êµ¬ì¡°
```csharp
public class PdfReportService
{
    private readonly ILogger<PdfReportService> _logger;

    public async Task<bool> GenerateAsync(
        ValidationResult result,
        string outputPath)
    {
        using var stream = new FileStream(outputPath, FileMode.Create);
        using var document = new Document(PageSize.A4);
        using var writer = PdfWriter.GetInstance(document, stream);

        document.Open();

        // í‘œì§€
        AddCoverPage(document, result);

        // ìš”ì•½
        AddSummaryPage(document, result);

        // ë‹¨ê³„ë³„ ìƒì„¸
        AddStageDetails(document, result);

        // ì˜¤ë¥˜ ëª©ë¡
        AddErrorList(document, result);

        // í†µê³„ ì°¨íŠ¸
        AddStatistics(document, result);

        document.Close();

        return true;
    }

    private void AddCoverPage(Document doc, ValidationResult result)
    {
        var titleFont = FontFactory.GetFont(
            FontFactory.HELVETICA_BOLD, 24, BaseColor.BLACK);
        var title = new Paragraph("ê³µê°„ë°ì´í„° ê²€ìˆ˜ ë³´ê³ ì„œ", titleFont);
        title.Alignment = Element.ALIGN_CENTER;
        title.SpacingAfter = 30f;
        doc.Add(title);

        var infoTable = new PdfPTable(2);
        infoTable.AddCell("ê²€ìˆ˜ ëŒ€ìƒ");
        infoTable.AddCell(result.TargetFile);
        infoTable.AddCell("ê²€ìˆ˜ ì¼ì‹œ");
        infoTable.AddCell(result.CompletedAt.ToString("yyyy-MM-dd HH:mm:ss"));
        infoTable.AddCell("ì´ ì˜¤ë¥˜ ìˆ˜");
        infoTable.AddCell(result.ErrorCount.ToString());
        doc.Add(infoTable);
    }

    private void AddSummaryPage(Document doc, ValidationResult result)
    {
        // ìš”ì•½ ì •ë³´ ì„¹ì…˜
        var summaryFont = FontFactory.GetFont(
            FontFactory.HELVETICA_BOLD, 16, BaseColor.BLACK);
        var summaryTitle = new Paragraph("ê²€ìˆ˜ ê²°ê³¼ ìš”ì•½", summaryFont);
        summaryTitle.SpacingBefore = 20f;
        doc.Add(summaryTitle);

        // ì „ì²´ ê²°ê³¼
        var statusColor = result.Status == ValidationStatus.Passed
            ? BaseColor.GREEN : BaseColor.RED;
        var statusChunk = new Chunk(
            result.Status.ToString(),
            FontFactory.GetFont(FontFactory.HELVETICA_BOLD, 14, statusColor));
        doc.Add(new Paragraph(statusChunk));

        // ì‹¬ê°ë„ë³„ ë¶„í¬
        var severityTable = new PdfPTable(2);
        severityTable.AddCell("ì‹¬ê°ë„");
        severityTable.AddCell("ì˜¤ë¥˜ ìˆ˜");

        var errorsBySeverity = result.GetErrorsBySeverity();
        foreach (var kvp in errorsBySeverity)
        {
            severityTable.AddCell(kvp.Key);
            severityTable.AddCell(kvp.Value.ToString());
        }
        doc.Add(severityTable);
    }

    private void AddStageDetails(Document doc, ValidationResult result)
    {
        // ê° ë‹¨ê³„ë³„ ìƒì„¸ ê²°ê³¼
        AddStageDetail(doc, "Stage 0: FileGDB ë¬´ê²°ì„±", result.FileGdbCheckResult);
        AddStageDetail(doc, "Stage 1: í…Œì´ë¸” ê²€ì‚¬", result.TableCheckResult);
        AddStageDetail(doc, "Stage 2: ìŠ¤í‚¤ë§ˆ ê²€ì‚¬", result.SchemaCheckResult);
        AddStageDetail(doc, "Stage 3: ì§€ì˜¤ë©”íŠ¸ë¦¬ ê²€ì‚¬", result.GeometryCheckResult);
        AddStageDetail(doc, "Stage 4: ì†ì„± ê²€ì‚¬", result.AttributeRelationCheckResult);
        AddStageDetail(doc, "Stage 5: ê³µê°„ ê´€ê³„ ê²€ì‚¬", result.RelationCheckResult);
    }

    private void AddErrorList(Document doc, ValidationResult result)
    {
        var errorFont = FontFactory.GetFont(
            FontFactory.HELVETICA_BOLD, 14, BaseColor.BLACK);
        var errorTitle = new Paragraph("ìƒì„¸ ì˜¤ë¥˜ ëª©ë¡", errorFont);
        errorTitle.SpacingBefore = 20f;
        doc.Add(errorTitle);

        var errorTable = new PdfPTable(5);
        errorTable.AddCell("ì˜¤ë¥˜ ì½”ë“œ");
        errorTable.AddCell("ì‹¬ê°ë„");
        errorTable.AddCell("í…Œì´ë¸”");
        errorTable.AddCell("í”¼ì²˜ ID");
        errorTable.AddCell("ì„¤ëª…");

        foreach (var error in result.GetAllErrors())
        {
            errorTable.AddCell(error.ErrorCode);
            errorTable.AddCell(error.Severity.ToString());
            errorTable.AddCell(error.TableName);
            errorTable.AddCell(error.FeatureId);
            errorTable.AddCell(error.Message);
        }

        doc.Add(errorTable);
    }
}
```

**ì˜ˆìƒ ì‹œê°„**: 40-50ì‹œê°„

#### Excel êµ¬í˜„ ìƒì„¸

##### ExcelReportService.cs êµ¬ì¡°
```csharp
public class ExcelReportService
{
    public async Task<bool> GenerateAsync(
        ValidationResult result,
        string outputPath)
    {
        using var package = new ExcelPackage();

        // ì‹œíŠ¸ ìƒì„±
        CreateSummarySheet(package, result);
        CreateStage0Sheet(package, result.FileGdbCheckResult);
        CreateStage1Sheet(package, result.TableCheckResult);
        CreateStage2Sheet(package, result.SchemaCheckResult);
        CreateStage3Sheet(package, result.GeometryCheckResult);
        CreateStage4Sheet(package, result.AttributeRelationCheckResult);
        CreateStage5Sheet(package, result.RelationCheckResult);
        CreateErrorListSheet(package, result);
        CreateStatisticsSheet(package, result);

        await package.SaveAsAsync(new FileInfo(outputPath));
        return true;
    }

    private void CreateSummarySheet(ExcelPackage package, ValidationResult result)
    {
        var ws = package.Workbook.Worksheets.Add("ìš”ì•½");

        // í—¤ë”
        ws.Cells["A1"].Value = "ê³µê°„ë°ì´í„° ê²€ìˆ˜ ë³´ê³ ì„œ";
        ws.Cells["A1:D1"].Merge = true;
        ws.Cells["A1"].Style.Font.Size = 18;
        ws.Cells["A1"].Style.Font.Bold = true;
        ws.Cells["A1"].Style.HorizontalAlignment = ExcelHorizontalAlignment.Center;

        // ê¸°ë³¸ ì •ë³´
        int row = 3;
        ws.Cells[row, 1].Value = "ê²€ìˆ˜ ëŒ€ìƒ";
        ws.Cells[row, 2].Value = result.TargetFile;
        row++;

        ws.Cells[row, 1].Value = "ê²€ìˆ˜ ì¼ì‹œ";
        ws.Cells[row, 2].Value = result.CompletedAt;
        ws.Cells[row, 2].Style.Numberformat.Format = "yyyy-MM-dd HH:mm:ss";
        row++;

        ws.Cells[row, 1].Value = "ì „ì²´ ê²°ê³¼";
        ws.Cells[row, 2].Value = result.Status.ToString();
        ws.Cells[row, 2].Style.Font.Color.SetColor(
            result.Status == ValidationStatus.Passed
                ? Color.Green : Color.Red);
        row++;

        ws.Cells[row, 1].Value = "ì´ ì˜¤ë¥˜ ìˆ˜";
        ws.Cells[row, 2].Value = result.ErrorCount;
        row += 2;

        // ë‹¨ê³„ë³„ ê²°ê³¼ í…Œì´ë¸”
        ws.Cells[row, 1].Value = "ë‹¨ê³„";
        ws.Cells[row, 2].Value = "ìƒíƒœ";
        ws.Cells[row, 3].Value = "ì˜¤ë¥˜ ìˆ˜";
        ws.Cells[row, 4].Value = "ê²½ê³  ìˆ˜";
        ws.Cells[row, 1, row, 4].Style.Font.Bold = true;
        ws.Cells[row, 1, row, 4].Style.Fill.PatternType = ExcelFillStyle.Solid;
        ws.Cells[row, 1, row, 4].Style.Fill.BackgroundColor.SetColor(Color.LightGray);
        row++;

        AddStageRow(ws, ref row, "Stage 0: FileGDB ë¬´ê²°ì„±", result.FileGdbCheckResult);
        AddStageRow(ws, ref row, "Stage 1: í…Œì´ë¸” ê²€ì‚¬", result.TableCheckResult);
        AddStageRow(ws, ref row, "Stage 2: ìŠ¤í‚¤ë§ˆ ê²€ì‚¬", result.SchemaCheckResult);
        AddStageRow(ws, ref row, "Stage 3: ì§€ì˜¤ë©”íŠ¸ë¦¬ ê²€ì‚¬", result.GeometryCheckResult);
        AddStageRow(ws, ref row, "Stage 4: ì†ì„± ê²€ì‚¬", result.AttributeRelationCheckResult);
        AddStageRow(ws, ref row, "Stage 5: ê³µê°„ ê´€ê³„ ê²€ì‚¬", result.RelationCheckResult);

        // ì—´ ë„ˆë¹„ ìë™ ì¡°ì •
        ws.Cells[ws.Dimension.Address].AutoFitColumns();
    }

    private void CreateErrorListSheet(ExcelPackage package, ValidationResult result)
    {
        var ws = package.Workbook.Worksheets.Add("ì˜¤ë¥˜ ëª©ë¡");

        // í—¤ë”
        ws.Cells["A1"].Value = "ì˜¤ë¥˜ ì½”ë“œ";
        ws.Cells["B1"].Value = "ì‹¬ê°ë„";
        ws.Cells["C1"].Value = "ë‹¨ê³„";
        ws.Cells["D1"].Value = "í…Œì´ë¸”";
        ws.Cells["E1"].Value = "í”¼ì²˜ ID";
        ws.Cells["F1"].Value = "ì„¤ëª…";

        ws.Cells["A1:F1"].Style.Font.Bold = true;
        ws.Cells["A1:F1"].Style.Fill.PatternType = ExcelFillStyle.Solid;
        ws.Cells["A1:F1"].Style.Fill.BackgroundColor.SetColor(Color.LightBlue);

        // ë°ì´í„°
        int row = 2;
        foreach (var error in result.GetAllErrors())
        {
            ws.Cells[row, 1].Value = error.ErrorCode;
            ws.Cells[row, 2].Value = error.Severity.ToString();
            ws.Cells[row, 3].Value = error.StageName;
            ws.Cells[row, 4].Value = error.TableName;
            ws.Cells[row, 5].Value = error.FeatureId;
            ws.Cells[row, 6].Value = error.Message;

            // ì‹¬ê°ë„ë³„ ìƒ‰ìƒ
            var severityColor = error.Severity switch
            {
                ErrorSeverity.Critical => Color.Red,
                ErrorSeverity.Major => Color.Orange,
                ErrorSeverity.Minor => Color.Yellow,
                _ => Color.White
            };
            ws.Cells[row, 2].Style.Fill.PatternType = ExcelFillStyle.Solid;
            ws.Cells[row, 2].Style.Fill.BackgroundColor.SetColor(severityColor);

            row++;
        }

        // í•„í„° ì¶”ê°€
        ws.Cells[1, 1, row - 1, 6].AutoFilter = true;

        // ì—´ ë„ˆë¹„ ì¡°ì •
        ws.Cells[ws.Dimension.Address].AutoFitColumns();
    }

    private void CreateStatisticsSheet(ExcelPackage package, ValidationResult result)
    {
        var ws = package.Workbook.Worksheets.Add("í†µê³„");

        // ì‹¬ê°ë„ë³„ ë¶„í¬
        ws.Cells["A1"].Value = "ì‹¬ê°ë„ë³„ ì˜¤ë¥˜ ë¶„í¬";
        ws.Cells["A1"].Style.Font.Bold = true;

        ws.Cells["A2"].Value = "ì‹¬ê°ë„";
        ws.Cells["B2"].Value = "ê°œìˆ˜";
        ws.Cells["A2:B2"].Style.Font.Bold = true;

        int row = 3;
        var errorsBySeverity = result.GetErrorsBySeverity();
        foreach (var kvp in errorsBySeverity)
        {
            ws.Cells[row, 1].Value = kvp.Key;
            ws.Cells[row, 2].Value = kvp.Value;
            row++;
        }

        // íŒŒì´ ì°¨íŠ¸ ì¶”ê°€
        var chart = ws.Drawings.AddChart("ì‹¬ê°ë„ë³„ ë¶„í¬", eChartType.Pie);
        chart.SetPosition(1, 0, 3, 0);
        chart.SetSize(400, 300);
        chart.Series.Add(ws.Cells[$"B3:B{row-1}"], ws.Cells[$"A3:A{row-1}"]);
        chart.Title.Text = "ì‹¬ê°ë„ë³„ ì˜¤ë¥˜ ë¶„í¬";

        // ì˜¤ë¥˜ ìœ í˜•ë³„ ë¶„í¬
        row += 2;
        ws.Cells[row, 1].Value = "ì˜¤ë¥˜ ìœ í˜•ë³„ ë¶„í¬";
        ws.Cells[row, 1].Style.Font.Bold = true;
        row++;

        ws.Cells[row, 1].Value = "ì˜¤ë¥˜ ìœ í˜•";
        ws.Cells[row, 2].Value = "ê°œìˆ˜";
        ws.Cells[row, 1, row, 2].Style.Font.Bold = true;
        row++;

        var startRow = row;
        var errorsByType = result.GetErrorsByType();
        foreach (var kvp in errorsByType)
        {
            ws.Cells[row, 1].Value = kvp.Key;
            ws.Cells[row, 2].Value = kvp.Value;
            row++;
        }

        // ë§‰ëŒ€ ì°¨íŠ¸ ì¶”ê°€
        var barChart = ws.Drawings.AddChart("ìœ í˜•ë³„ ë¶„í¬", eChartType.ColumnClustered);
        barChart.SetPosition(startRow - 2, 0, 3, 0);
        barChart.SetSize(400, 300);
        barChart.Series.Add(ws.Cells[$"B{startRow}:B{row-1}"], ws.Cells[$"A{startRow}:A{row-1}"]);
        barChart.Title.Text = "ì˜¤ë¥˜ ìœ í˜•ë³„ ë¶„í¬";
    }
}
```

**ì˜ˆìƒ ì‹œê°„**: 30-40ì‹œê°„

---

### P2-1: AttributeCheckProcessor ì™„ì„±

#### ëª©í‘œ
`4_attribute_check.csv`ì˜ 93ê°œ ì†ì„± ê´€ê³„ ê·œì¹™ì„ ì™„ì „íˆ êµ¬í˜„

#### êµ¬í˜„ ì „ëµ

##### ê·œì¹™ êµ¬ì¡° ì˜ˆì‹œ
```csv
RuleID,SourceTable,SourceField,Condition,TargetTable,TargetField,RelationType,ErrorMessage
ATTR001,A0010000,A001_001,NOT NULL,,,SELF,A001_001 í•„ë“œëŠ” í•„ìˆ˜ì…ë‹ˆë‹¤
ATTR002,A0010000,A001_002,IN_CODELIST,CODELIST,A001_002,LOOKUP,ìœ íš¨í•˜ì§€ ì•Šì€ ì½”ë“œê°’ì…ë‹ˆë‹¤
ATTR003,A0010000,A001_003,>=,A0010000,A001_004,SELF,ì‹œì‘ê°’ì´ ì¢…ë£Œê°’ë³´ë‹¤ í½ë‹ˆë‹¤
ATTR004,A0010000,A001_005,EXISTS,A0020000,A002_001,FK,ì°¸ì¡° ë¬´ê²°ì„± ìœ„ë°˜
```

##### êµ¬í˜„ ë‹¨ê³„

**1ë‹¨ê³„: ê·œì¹™ íŒŒì„œ êµ¬í˜„ (10h)**
```csharp
public class AttributeRuleParser
{
    public List<AttributeRule> ParseRules(List<AttributeCheckConfig> configs)
    {
        var rules = new List<AttributeRule>();

        foreach (var config in configs)
        {
            var rule = new AttributeRule
            {
                RuleId = config.RuleID,
                SourceTable = config.SourceTable,
                SourceField = config.SourceField,
                Condition = ParseCondition(config.Condition),
                TargetTable = config.TargetTable,
                TargetField = config.TargetField,
                RelationType = ParseRelationType(config.RelationType),
                ErrorMessage = config.ErrorMessage
            };

            rules.Add(rule);
        }

        return rules;
    }

    private ConditionType ParseCondition(string condition)
    {
        return condition.ToUpper() switch
        {
            "NOT NULL" => ConditionType.NotNull,
            "IN_CODELIST" => ConditionType.InCodelist,
            ">=" => ConditionType.GreaterOrEqual,
            "<=" => ConditionType.LessOrEqual,
            "=" => ConditionType.Equal,
            "EXISTS" => ConditionType.Exists,
            _ => throw new NotSupportedException($"Unsupported condition: {condition}")
        };
    }
}
```

**2ë‹¨ê³„: ê·œì¹™ í‰ê°€ ì—”ì§„ (20h)**
```csharp
public class AttributeRuleEvaluator
{
    private readonly Dictionary<string, HashSet<string>> _codelists;
    private readonly IDataProvider _dataProvider;

    public async Task<List<ValidationError>> EvaluateRuleAsync(
        AttributeRule rule,
        Layer sourceLayer,
        CancellationToken cancellationToken)
    {
        var errors = new List<ValidationError>();

        sourceLayer.ResetReading();
        while (sourceLayer.GetNextFeature() is Feature feature)
        {
            if (cancellationToken.IsCancellationRequested) break;

            var error = await EvaluateFeatureAsync(rule, feature);
            if (error != null)
                errors.Add(error);
        }

        return errors;
    }

    private async Task<ValidationError?> EvaluateFeatureAsync(
        AttributeRule rule,
        Feature feature)
    {
        var sourceValue = GetFieldValue(feature, rule.SourceField);

        return rule.Condition switch
        {
            ConditionType.NotNull => EvaluateNotNull(sourceValue, rule, feature),
            ConditionType.InCodelist => EvaluateInCodelist(sourceValue, rule, feature),
            ConditionType.GreaterOrEqual => EvaluateComparison(sourceValue, rule, feature, (a, b) => a >= b),
            ConditionType.Exists => await EvaluateExists(sourceValue, rule, feature),
            _ => null
        };
    }

    private ValidationError? EvaluateNotNull(
        object? value,
        AttributeRule rule,
        Feature feature)
    {
        if (value == null || string.IsNullOrWhiteSpace(value.ToString()))
        {
            return new ValidationError
            {
                ErrorCode = rule.RuleId,
                Severity = ErrorSeverity.Critical,
                TableName = rule.SourceTable,
                FeatureId = feature.GetFID().ToString(),
                Message = rule.ErrorMessage
            };
        }
        return null;
    }

    private ValidationError? EvaluateInCodelist(
        object? value,
        AttributeRule rule,
        Feature feature)
    {
        if (value == null) return null;

        var codelistKey = rule.TargetField; // Codelist ì‹ë³„ì
        if (!_codelists.TryGetValue(codelistKey, out var validCodes))
        {
            throw new InvalidOperationException($"Codelist not found: {codelistKey}");
        }

        if (!validCodes.Contains(value.ToString()!))
        {
            return new ValidationError
            {
                ErrorCode = rule.RuleId,
                Severity = ErrorSeverity.Major,
                TableName = rule.SourceTable,
                FeatureId = feature.GetFID().ToString(),
                Message = $"{rule.ErrorMessage} (ê°’: {value})"
            };
        }
        return null;
    }

    private async Task<ValidationError?> EvaluateExists(
        object? value,
        AttributeRule rule,
        Feature feature)
    {
        if (value == null) return null;

        // ì°¸ì¡° í…Œì´ë¸”ì—ì„œ ê°’ ì¡´ì¬ ì—¬ë¶€ í™•ì¸
        var targetLayer = await _dataProvider.GetLayerAsync(rule.TargetTable);
        targetLayer.SetAttributeFilter($"{rule.TargetField} = '{value}'");
        var count = targetLayer.GetFeatureCount(1);

        if (count == 0)
        {
            return new ValidationError
            {
                ErrorCode = rule.RuleId,
                Severity = ErrorSeverity.Major,
                TableName = rule.SourceTable,
                FeatureId = feature.GetFID().ToString(),
                Message = $"{rule.ErrorMessage} (ì°¸ì¡°ê°’: {value})"
            };
        }
        return null;
    }
}
```

**3ë‹¨ê³„: ConditionalRuleEngine í†µí•© (15h)**
```csharp
public class ConditionalRuleEngine
{
    public async Task<bool> EvaluateConditionAsync(
        string condition,
        Feature feature,
        Dictionary<string, object> context)
    {
        // ë³µì¡í•œ ì¡°ê±´ í‘œí˜„ì‹ íŒŒì‹± ë° í‰ê°€
        // ì˜ˆ: "A001_001 > 100 AND A001_002 IN ('01', '02')"

        var expression = ParseExpression(condition);
        return await expression.EvaluateAsync(feature, context);
    }
}
```

**4ë‹¨ê³„: ë³‘ë ¬ ì²˜ë¦¬ ë° ìµœì í™” (10h)**
```csharp
public async Task<List<ValidationError>> ValidateAsync(
    string gdbPath,
    List<AttributeCheckConfig> rules,
    CancellationToken token)
{
    var allErrors = new ConcurrentBag<ValidationError>();

    // í…Œì´ë¸”ë³„ë¡œ ê·œì¹™ ê·¸ë£¹í™”
    var rulesByTable = rules.GroupBy(r => r.SourceTable);

    await Parallel.ForEachAsync(
        rulesByTable,
        new ParallelOptions
        {
            MaxDegreeOfParallelism = Environment.ProcessorCount,
            CancellationToken = token
        },
        async (tableRules, ct) =>
        {
            using var ds = Gdal.OpenEx(gdbPath, 0, null, null, null);
            var layer = ds.GetLayerByName(tableRules.Key);

            foreach (var rule in tableRules)
            {
                var errors = await EvaluateRuleAsync(rule, layer, ct);
                foreach (var error in errors)
                    allErrors.Add(error);
            }
        });

    return allErrors.ToList();
}
```

**ì˜ˆìƒ ì‹œê°„**: 50-60ì‹œê°„

---

### P2-2: RelationCheckProcessor ì™„ì„±

#### ëª©í‘œ
`5_relation_check.csv`ì˜ 20ê°œ ê³µê°„ ê´€ê³„ ê·œì¹™ì„ ì™„ì „íˆ êµ¬í˜„

#### ê³µê°„ ê´€ê³„ íƒ€ì…
- **Case1**: Intersects, Contains, Within, Touches, Crosses, Overlaps
- **Case2**: Buffer ê¸°ë°˜ ê´€ê³„ (ì˜ˆ: Aê°€ Bë¡œë¶€í„° 10m ì´ë‚´ì— ìˆì–´ì•¼ í•¨)
- **Case3**: Topology ê·œì¹™ (ì˜ˆ: Aì˜ ê²½ê³„ê°€ Bì— ì™„ì „íˆ í¬í•¨ë˜ì–´ì•¼ í•¨)

#### êµ¬í˜„ ë‹¨ê³„

**1ë‹¨ê³„: ê³µê°„ ì¸ë±ìŠ¤ êµ¬ì¶• (15h)**
```csharp
public class SpatialRelationValidator
{
    private readonly SpatialIndexManager _indexManager;

    public async Task<SpatialIndex> BuildIndexAsync(
        Layer layer,
        CancellationToken token)
    {
        var index = _indexManager.CreateIndex(IndexType.RTree);

        layer.ResetReading();
        while (layer.GetNextFeature() is Feature feature)
        {
            if (token.IsCancellationRequested) break;

            var envelope = new Envelope();
            feature.GetGeometryRef().GetEnvelope(envelope);

            index.Insert(
                feature.GetFID(),
                envelope.MinX, envelope.MinY,
                envelope.MaxX, envelope.MaxY);
        }

        return index;
    }
}
```

**2ë‹¨ê³„: Case1 - ê¸°ë³¸ ê³µê°„ ê´€ê³„ (15h)**
```csharp
private async Task<List<ValidationError>> ValidateCase1Async(
    RelationCheckConfig rule,
    Layer sourceLayer,
    Layer targetLayer,
    SpatialIndex targetIndex)
{
    var errors = new List<ValidationError>();

    sourceLayer.ResetReading();
    while (sourceLayer.GetNextFeature() is Feature sourceFeature)
    {
        var sourceGeom = sourceFeature.GetGeometryRef();
        var envelope = new Envelope();
        sourceGeom.GetEnvelope(envelope);

        // ê³µê°„ ì¸ë±ìŠ¤ë¡œ í›„ë³´ ê²€ìƒ‰
        var candidates = targetIndex.Query(
            envelope.MinX, envelope.MinY,
            envelope.MaxX, envelope.MaxY);

        bool relationFound = false;
        foreach (var candidateId in candidates)
        {
            var targetFeature = targetLayer.GetFeature(candidateId);
            var targetGeom = targetFeature.GetGeometryRef();

            // ì‹¤ì œ ê³µê°„ ê´€ê³„ ê²€ì‚¬
            relationFound = rule.RelationType switch
            {
                "Intersects" => sourceGeom.Intersects(targetGeom),
                "Contains" => sourceGeom.Contains(targetGeom),
                "Within" => sourceGeom.Within(targetGeom),
                "Touches" => sourceGeom.Touches(targetGeom),
                "Crosses" => sourceGeom.Crosses(targetGeom),
                "Overlaps" => sourceGeom.Overlaps(targetGeom),
                _ => false
            };

            if (relationFound) break;
        }

        if (!relationFound)
        {
            errors.Add(new ValidationError
            {
                ErrorCode = rule.RuleID,
                Severity = ErrorSeverity.Major,
                TableName = rule.SourceTable,
                FeatureId = sourceFeature.GetFID().ToString(),
                Message = $"{rule.ErrorMessage} (ê´€ê³„: {rule.RelationType})"
            });
        }
    }

    return errors;
}
```

**3ë‹¨ê³„: Case2 - Buffer ê¸°ë°˜ ê´€ê³„ (12h)**
```csharp
private async Task<List<ValidationError>> ValidateCase2Async(
    RelationCheckConfig rule,
    Layer sourceLayer,
    Layer targetLayer,
    double bufferDistance)
{
    var errors = new List<ValidationError>();

    sourceLayer.ResetReading();
    while (sourceLayer.GetNextFeature() is Feature sourceFeature)
    {
        var sourceGeom = sourceFeature.GetGeometryRef();
        var bufferedGeom = sourceGeom.Buffer(bufferDistance, 30);

        // Buffer ì˜ì—­ ë‚´ ëŒ€ìƒ ê°ì²´ ê²€ìƒ‰
        targetLayer.SetSpatialFilter(bufferedGeom);
        var count = targetLayer.GetFeatureCount(1);

        if (count == 0)
        {
            errors.Add(new ValidationError
            {
                ErrorCode = rule.RuleID,
                Severity = ErrorSeverity.Minor,
                TableName = rule.SourceTable,
                FeatureId = sourceFeature.GetFID().ToString(),
                Message = $"{rule.ErrorMessage} (ë²„í¼ ê±°ë¦¬: {bufferDistance}m)"
            });
        }

        targetLayer.SetSpatialFilter(null);
    }

    return errors;
}
```

**4ë‹¨ê³„: Case3 - í† í´ë¡œì§€ ê·œì¹™ (13h)**
```csharp
private async Task<List<ValidationError>> ValidateCase3Async(
    RelationCheckConfig rule,
    Layer sourceLayer,
    Layer targetLayer)
{
    var errors = new List<ValidationError>();

    // ì˜ˆ: í´ë¦¬ê³¤ì˜ ê²½ê³„ê°€ ë¼ì¸ì— ì™„ì „íˆ í¬í•¨ë˜ì–´ì•¼ í•¨
    sourceLayer.ResetReading();
    while (sourceLayer.GetNextFeature() is Feature sourceFeature)
    {
        var sourceGeom = sourceFeature.GetGeometryRef();
        var sourceBoundary = sourceGeom.GetBoundary();

        // ëª¨ë“  íƒ€ê²Ÿ ë¼ì¸ ë³‘í•©
        var targetUnion = CombineTargetGeometries(targetLayer);

        // ê²½ê³„ê°€ ì™„ì „íˆ í¬í•¨ë˜ëŠ”ì§€ í™•ì¸
        if (!sourceBoundary.Within(targetUnion))
        {
            errors.Add(new ValidationError
            {
                ErrorCode = rule.RuleID,
                Severity = ErrorSeverity.Critical,
                TableName = rule.SourceTable,
                FeatureId = sourceFeature.GetFID().ToString(),
                Message = rule.ErrorMessage
            });
        }
    }

    return errors;
}
```

**5ë‹¨ê³„: ë³‘ë ¬ ì²˜ë¦¬ ë° í†µí•© (5h)**

**ì˜ˆìƒ ì‹œê°„**: 50-60ì‹œê°„

---

### P2-3: GdbToSqliteConverter ì™„ì „ êµ¬í˜„

#### ëª©í‘œ
FileGDBë¥¼ SQLite/SpatiaLiteë¡œ ì™„ì „íˆ ë³€í™˜í•˜ì—¬ ê³ ì„±ëŠ¥ ì¿¼ë¦¬ ì§€ì›

#### êµ¬í˜„ ë‹¨ê³„

**1ë‹¨ê³„: SpatiaLite ì´ˆê¸°í™” (8h)**
```csharp
private void InitializeSpatiaLite(SqliteConnection connection)
{
    connection.Open();

    // SpatiaLite í™•ì¥ ë¡œë“œ
    connection.LoadExtension("mod_spatialite");

    // ê³µê°„ ë©”íƒ€ë°ì´í„° ì´ˆê¸°í™”
    using var cmd = connection.CreateCommand();
    cmd.CommandText = "SELECT InitSpatialMetaData(1)";
    cmd.ExecuteNonQuery();
}
```

**2ë‹¨ê³„: ìŠ¤í‚¤ë§ˆ ë³€í™˜ (12h)**
```csharp
private void CreateTableSchema(
    Layer layer,
    SqliteConnection connection,
    string tableName)
{
    var layerDefn = layer.GetLayerDefn();
    var columns = new List<string>();

    // í•„ë“œ ì •ì˜ ë³€í™˜
    for (int i = 0; i < layerDefn.GetFieldCount(); i++)
    {
        var fieldDefn = layerDefn.GetFieldDefn(i);
        var fieldName = fieldDefn.GetName();
        var fieldType = MapOgrTypeToSqliteType(fieldDefn.GetFieldType());

        columns.Add($"{fieldName} {fieldType}");
    }

    // í…Œì´ë¸” ìƒì„±
    using var cmd = connection.CreateCommand();
    cmd.CommandText = $@"
        CREATE TABLE {tableName} (
            fid INTEGER PRIMARY KEY AUTOINCREMENT,
            {string.Join(",\n            ", columns)}
        )";
    cmd.ExecuteNonQuery();

    // ì§€ì˜¤ë©”íŠ¸ë¦¬ ì»¬ëŸ¼ ì¶”ê°€
    var geomType = layer.GetGeomType();
    var srs = layer.GetSpatialRef();
    var epsg = GetEpsgCode(srs);

    cmd.CommandText = $@"
        SELECT AddGeometryColumn(
            '{tableName}',
            'geometry',
            {epsg},
            '{MapGeometryType(geomType)}',
            'XY'
        )";
    cmd.ExecuteNonQuery();

    // ê³µê°„ ì¸ë±ìŠ¤ ìƒì„±
    cmd.CommandText = $"SELECT CreateSpatialIndex('{tableName}', 'geometry')";
    cmd.ExecuteNonQuery();
}

private string MapOgrTypeToSqliteType(FieldType ogrType)
{
    return ogrType switch
    {
        FieldType.OFTInteger => "INTEGER",
        FieldType.OFTInteger64 => "INTEGER",
        FieldType.OFTReal => "REAL",
        FieldType.OFTString => "TEXT",
        FieldType.OFTDate => "TEXT",
        FieldType.OFTDateTime => "TEXT",
        FieldType.OFTBinary => "BLOB",
        _ => "TEXT"
    };
}
```

**3ë‹¨ê³„: ë°ì´í„° ë³€í™˜ (15h)**
```csharp
private async Task CopyLayerDataAsync(
    Layer layer,
    SqliteConnection connection,
    string tableName,
    IProgress<int> progress,
    CancellationToken cancellationToken)
{
    var layerDefn = layer.GetLayerDefn();
    var fieldCount = layerDefn.GetFieldCount();

    // í•„ë“œëª… ëª©ë¡
    var fieldNames = new List<string>();
    for (int i = 0; i < fieldCount; i++)
    {
        fieldNames.Add(layerDefn.GetFieldDefn(i).GetName());
    }

    // INSERT ë¬¸ ì¤€ë¹„
    var placeholders = string.Join(", ", Enumerable.Range(0, fieldCount + 1).Select(i => $"@p{i}"));
    var insertSql = $@"
        INSERT INTO {tableName} ({string.Join(", ", fieldNames)}, geometry)
        VALUES ({placeholders})";

    using var transaction = connection.BeginTransaction();
    using var cmd = connection.CreateCommand();
    cmd.CommandText = insertSql;

    int processedCount = 0;
    int totalCount = (int)layer.GetFeatureCount(1);

    layer.ResetReading();
    while (layer.GetNextFeature() is Feature feature)
    {
        if (cancellationToken.IsCancellationRequested)
        {
            transaction.Rollback();
            throw new OperationCanceledException();
        }

        cmd.Parameters.Clear();

        // ì†ì„± ê°’ ë°”ì¸ë”©
        for (int i = 0; i < fieldCount; i++)
        {
            var value = GetFieldValueAsObject(feature, i);
            cmd.Parameters.AddWithValue($"@p{i}", value ?? DBNull.Value);
        }

        // ì§€ì˜¤ë©”íŠ¸ë¦¬ ë°”ì¸ë”© (WKB)
        var geom = feature.GetGeometryRef();
        if (geom != null)
        {
            var wkb = new byte[geom.WkbSize()];
            geom.ExportToWkb(wkb);
            cmd.Parameters.AddWithValue($"@p{fieldCount}", wkb);
        }
        else
        {
            cmd.Parameters.AddWithValue($"@p{fieldCount}", DBNull.Value);
        }

        await cmd.ExecuteNonQueryAsync(cancellationToken);

        processedCount++;
        if (processedCount % 1000 == 0)
        {
            progress?.Report((int)((double)processedCount / totalCount * 100));
        }
    }

    transaction.Commit();
}

private object? GetFieldValueAsObject(Feature feature, int fieldIndex)
{
    if (!feature.IsFieldSet(fieldIndex))
        return null;

    var fieldDefn = feature.GetDefnRef().GetFieldDefn(fieldIndex);
    return fieldDefn.GetFieldType() switch
    {
        FieldType.OFTInteger => feature.GetFieldAsInteger(fieldIndex),
        FieldType.OFTInteger64 => feature.GetFieldAsInteger64(fieldIndex),
        FieldType.OFTReal => feature.GetFieldAsDouble(fieldIndex),
        FieldType.OFTString => feature.GetFieldAsString(fieldIndex),
        _ => feature.GetFieldAsString(fieldIndex)
    };
}
```

**4ë‹¨ê³„: ë³‘ë ¬ í…Œì´ë¸” ë³€í™˜ (10h)**
```csharp
public async Task<string> ConvertAsync(
    string gdbPath,
    IProgress<ConversionProgress> progress,
    CancellationToken cancellationToken)
{
    var tempPath = Path.Combine(Path.GetTempPath(), $"temp_{Guid.NewGuid()}.sqlite");

    using var connection = new SqliteConnection($"Data Source={tempPath}");
    InitializeSpatiaLite(connection);

    using var ds = Gdal.OpenEx(gdbPath, 0, null, null, null);
    var layerCount = ds.GetLayerCount();

    for (int i = 0; i < layerCount; i++)
    {
        if (cancellationToken.IsCancellationRequested)
        {
            File.Delete(tempPath);
            throw new OperationCanceledException();
        }

        var layer = ds.GetLayerByIndex(i);
        var layerName = layer.GetName();

        _logger.LogInformation("ë ˆì´ì–´ ë³€í™˜ ì¤‘: {LayerName} ({Current}/{Total})",
            layerName, i + 1, layerCount);

        CreateTableSchema(layer, connection, layerName);

        await CopyLayerDataAsync(
            layer,
            connection,
            layerName,
            new Progress<int>(p => progress?.Report(new ConversionProgress
            {
                CurrentLayer = layerName,
                LayerIndex = i,
                TotalLayers = layerCount,
                LayerProgress = p
            })),
            cancellationToken);
    }

    connection.Close();

    _logger.LogInformation("ë³€í™˜ ì™„ë£Œ: {OutputPath}", tempPath);
    return tempPath;
}
```

**ì˜ˆìƒ ì‹œê°„**: 40-60ì‹œê°„

---

## ì•„í‚¤í…ì²˜ ê°œì„  ê¶Œê³ 

### 1. Reflection ê¸°ë°˜ Stage ì œì–´ ì œê±°

**í˜„ì¬ ë¬¸ì œ**:
```csharp
// SimpleValidationService.cs Line 909-920
private bool ShouldRunStage(int stageNumber)
{
    try
    {
        var mainWindow = Application.Current.MainWindow;
        var checkBoxName = $"cbStage{stageNumber}";
        var checkBox = mainWindow?.FindName(checkBoxName) as CheckBox;
        return checkBox?.IsChecked ?? false;
    }
    catch
    {
        return false;
    }
}
```

**ê°œì„  ë°©ì•ˆ**:
```csharp
// 1. ì¸í„°í˜ì´ìŠ¤ ì •ì˜
public interface IStageConfiguration
{
    bool IsStageEnabled(int stageNumber);
}

// 2. ViewModel êµ¬í˜„
public class ValidationConfigViewModel : IStageConfiguration
{
    public bool Stage0Enabled { get; set; } = true;
    public bool Stage1Enabled { get; set; } = true;
    public bool Stage2Enabled { get; set; } = true;
    public bool Stage3Enabled { get; set; } = true;
    public bool Stage4Enabled { get; set; } = true;
    public bool Stage5Enabled { get; set; } = true;

    public bool IsStageEnabled(int stageNumber)
    {
        return stageNumber switch
        {
            0 => Stage0Enabled,
            1 => Stage1Enabled,
            2 => Stage2Enabled,
            3 => Stage3Enabled,
            4 => Stage4Enabled,
            5 => Stage5Enabled,
            _ => false
        };
    }
}

// 3. DI ì£¼ì…
public class SimpleValidationService
{
    private readonly IStageConfiguration _stageConfig;

    public SimpleValidationService(IStageConfiguration stageConfig)
    {
        _stageConfig = stageConfig;
    }

    private bool ShouldRunStage(int stageNumber)
    {
        return _stageConfig.IsStageEnabled(stageNumber);
    }
}
```

---

### 2. Dynamic Casting ì œê±°

**í˜„ì¬ ë¬¸ì œ**:
```csharp
// StageParallelProcessingManager.cs
var result = await processor.ProcessAsync((dynamic)filePath, (dynamic)config, cancellationToken);
```

**ê°œì„  ë°©ì•ˆ**:
```csharp
// 1. ê³µí†µ ì¸í„°í˜ì´ìŠ¤
public interface IValidationProcessor<TConfig>
{
    Task<CheckResult> ProcessAsync(string filePath, TConfig config, CancellationToken cancellationToken);
}

// 2. ì œë„¤ë¦­ ì‹¤í–‰ê¸°
public class StageExecutor<TConfig>
{
    private readonly IValidationProcessor<TConfig> _processor;

    public async Task<CheckResult> ExecuteAsync(
        string filePath,
        TConfig config,
        CancellationToken cancellationToken)
    {
        return await _processor.ProcessAsync(filePath, config, cancellationToken);
    }
}
```

---

### 3. ì½”ë“œ ì¤‘ë³µ ì œê±°

ë³‘ë ¬ ì‹¤í–‰ê³¼ ìˆœì°¨ ì‹¤í–‰ ë¡œì§ í†µí•©:

```csharp
public async Task<ValidationResult> ValidateAsync(
    string filePath,
    bool useParallel = false)
{
    var executor = useParallel
        ? (IStageExecutor)new ParallelStageExecutor(_parallelManager)
        : new SequentialStageExecutor();

    return await executor.ExecuteAllStagesAsync(filePath, _configs);
}
```

---

## í…ŒìŠ¤íŠ¸ ì „ëµ

### ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ (Unit Tests)

#### 1. Processorë³„ í…ŒìŠ¤íŠ¸
```csharp
[TestClass]
public class SchemaCheckProcessorTests
{
    [TestMethod]
    public async Task ValidateAsync_MissingColumn_ReturnsError()
    {
        // Arrange
        var processor = new SchemaCheckProcessor();
        var config = new SchemaCheckConfig
        {
            TableName = "TestTable",
            RequiredFields = new[] { "OBJECTID", "SHAPE", "NAME" }
        };

        // Act
        var result = await processor.ProcessAsync(TestData.GdbPath, config);

        // Assert
        Assert.IsFalse(result.IsValid);
        Assert.AreEqual(1, result.Errors.Count);
        Assert.AreEqual("SCH001", result.Errors[0].ErrorCode);
    }

    [TestMethod]
    public async Task ValidateAsync_WrongDataType_ReturnsError()
    {
        // Test data type mismatch detection
    }

    [TestMethod]
    public async Task ValidateAsync_PrimaryKeyDuplicate_ReturnsError()
    {
        // Test PK uniqueness validation
    }
}
```

#### 2. ì„œë¹„ìŠ¤ ë¡œì§ í…ŒìŠ¤íŠ¸
```csharp
[TestClass]
public class QcErrorServiceTests
{
    [TestMethod]
    public async Task SaveGeometryValidationResultsAsync_CreatesQcErrors()
    {
        // Test QC error creation and storage
    }

    [TestMethod]
    public async Task ClassifyErrors_SeparatesGeometryAndNonGeometry()
    {
        // Test error classification logic
    }
}
```

#### 3. ë³€í™˜ê¸° í…ŒìŠ¤íŠ¸
```csharp
[TestClass]
public class GdbToSqliteConverterTests
{
    [TestMethod]
    public async Task ConvertAsync_PreservesSchema()
    {
        // Verify schema is correctly converted
    }

    [TestMethod]
    public async Task ConvertAsync_PreservesData()
    {
        // Verify all features are copied
    }

    [TestMethod]
    public async Task ConvertAsync_PreservesGeometry()
    {
        // Verify geometries are correctly converted to WKB
    }
}
```

---

### í†µí•© í…ŒìŠ¤íŠ¸ (Integration Tests)

#### 1. ì „ì²´ ê²€ìˆ˜ í”„ë¡œì„¸ìŠ¤
```csharp
[TestClass]
public class ValidationIntegrationTests
{
    [TestMethod]
    public async Task EndToEnd_ValidGdb_ReturnsSuccess()
    {
        // Test complete validation workflow
        var service = new SimpleValidationService(/* dependencies */);
        var result = await service.ValidateAsync(TestData.ValidGdbPath);

        Assert.IsTrue(result.IsValid);
        Assert.AreEqual(0, result.ErrorCount);
    }

    [TestMethod]
    public async Task EndToEnd_InvalidGdb_ReturnsErrors()
    {
        // Test validation with known errors
        var service = new SimpleValidationService(/* dependencies */);
        var result = await service.ValidateAsync(TestData.InvalidGdbPath);

        Assert.IsFalse(result.IsValid);
        Assert.IsTrue(result.ErrorCount > 0);
    }
}
```

#### 2. ë³´ê³ ì„œ ìƒì„±
```csharp
[TestClass]
public class ReportGenerationIntegrationTests
{
    [TestMethod]
    public async Task GeneratePdf_CreatesValidFile()
    {
        var service = new PdfReportService();
        var outputPath = Path.Combine(Path.GetTempPath(), "test_report.pdf");

        var success = await service.GenerateAsync(TestData.ValidationResult, outputPath);

        Assert.IsTrue(success);
        Assert.IsTrue(File.Exists(outputPath));
        Assert.IsTrue(new FileInfo(outputPath).Length > 1024); // At least 1KB
    }
}
```

---

### ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ (Performance Tests)

#### 1. ëŒ€ìš©ëŸ‰ íŒŒì¼ ì²˜ë¦¬
```csharp
[TestClass]
public class PerformanceTests
{
    [TestMethod]
    [Timeout(300000)] // 5 minutes
    public async Task ValidateAsync_LargeGdb_CompletesInTime()
    {
        // Test with 1GB+ GDB file
        var service = new SimpleValidationService(/* dependencies */);
        var result = await service.ValidateAsync(TestData.LargeGdbPath);

        Assert.IsNotNull(result);
    }

    [TestMethod]
    public async Task GdbToSqlite_Conversion_IsFasterThanDirect()
    {
        // Compare performance: SQLite vs direct GDB access
    }
}
```

#### 2. ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰
```csharp
[TestMethod]
public async Task ValidateAsync_LargeGdb_StaysWithinMemoryLimit()
{
    var initialMemory = GC.GetTotalMemory(true);

    var service = new SimpleValidationService(/* dependencies */);
    await service.ValidateAsync(TestData.LargeGdbPath);

    var finalMemory = GC.GetTotalMemory(true);
    var memoryIncrease = finalMemory - initialMemory;

    // Should not exceed 2GB
    Assert.IsTrue(memoryIncrease < 2L * 1024 * 1024 * 1024);
}
```

---

## ì˜ˆìƒ ì¼ì • ë° ë¦¬ì†ŒìŠ¤

### Phase 1: ê¸´ê¸‰ ìˆ˜ì • (3-4ì£¼)

**ëª©í‘œ**: í”„ë¡œë•ì…˜ ìµœì†Œ ìš”êµ¬ì‚¬í•­ ì¶©ì¡±

| ì‘ì—… | ë‹´ë‹¹ | ì˜ˆìƒ ì‹œê°„ | ë¹„ê³  |
|------|------|----------|------|
| SchemaCheckProcessor êµ¬í˜„ | ê°œë°œì A | 40h | P1-1 |
| PdfReportService êµ¬í˜„ | ê°œë°œì B | 50h | P1-2 |
| ExcelReportService êµ¬í˜„ | ê°œë°œì B | 40h | P1-3 |
| í†µí•© í…ŒìŠ¤íŠ¸ | QA | 20h | |
| **ì†Œê³„** | | **150h** | **ì•½ 4ì£¼** |

---

### Phase 2: í•µì‹¬ ê¸°ëŠ¥ ì™„ì„± (5-6ì£¼)

**ëª©í‘œ**: ëª¨ë“  ê²€ìˆ˜ ë‹¨ê³„ ì™„ì „ êµ¬í˜„

| ì‘ì—… | ë‹´ë‹¹ | ì˜ˆìƒ ì‹œê°„ | ë¹„ê³  |
|------|------|----------|------|
| AttributeCheckProcessor ì™„ì„± | ê°œë°œì A | 60h | P2-1 |
| RelationCheckProcessor ì™„ì„± | ê°œë°œì C | 60h | P2-2 |
| GdbToSqliteConverter êµ¬í˜„ | ê°œë°œì D | 60h | P2-3 |
| ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ ë° ìµœì í™” | ì „ì²´ | 40h | |
| **ì†Œê³„** | | **220h** | **ì•½ 6ì£¼** |

---

### Phase 3: í’ˆì§ˆ ê°œì„  (4-5ì£¼)

**ëª©í‘œ**: ìœ ì§€ë³´ìˆ˜ì„± ë° í™•ì¥ì„± í–¥ìƒ

| ì‘ì—… | ë‹´ë‹¹ | ì˜ˆìƒ ì‹œê°„ | ë¹„ê³  |
|------|------|----------|------|
| ì•„í‚¤í…ì²˜ ë¦¬íŒ©í† ë§ | ê°œë°œì A | 40h | P3-1 |
| ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ êµ¬ì¶• | ì „ì²´ | 80h | P3-2 |
| HtmlReportService êµ¬í˜„ | ê°œë°œì B | 40h | P3-3 |
| ì„±ëŠ¥ í”„ë¡œíŒŒì¼ë§ ë° ê°œì„  | ê°œë°œì C | 30h | P3-4 |
| ë¬¸ì„œ ë™ê¸°í™” | Tech Writer | 15h | P3-5 |
| **ì†Œê³„** | | **205h** | **ì•½ 5ì£¼** |

---

### ì´ ì˜ˆìƒ ì¼ì •

| Phase | ê¸°ê°„ | ëˆ„ì  ì‹œê°„ | íŒ€ ê·œëª¨ |
|-------|------|----------|---------|
| Phase 1 | 4ì£¼ | 150h | 2ëª… |
| Phase 2 | 6ì£¼ | 370h | 4ëª… |
| Phase 3 | 5ì£¼ | 575h | 4ëª… |
| **ì´ê³„** | **15ì£¼** | **575h** | **ìµœëŒ€ 4ëª…** |

---

## ìš°ì„ ìˆœìœ„ ë¡œë“œë§µ

### Milestone 1: MVP (4ì£¼)
- âœ… SchemaCheckProcessor
- âœ… PdfReportService
- âœ… ExcelReportService
- **ê²°ê³¼**: ê¸°ë³¸ì ì¸ ê²€ìˆ˜ ë° ë³´ê³ ì„œ ìƒì„± ê°€ëŠ¥

### Milestone 2: ì™„ì „í•œ ê²€ìˆ˜ (10ì£¼)
- âœ… AttributeCheckProcessor
- âœ… RelationCheckProcessor
- âœ… GdbToSqliteConverter
- **ê²°ê³¼**: ëª¨ë“  ê²€ìˆ˜ ë‹¨ê³„ ì™„ì „ ì‘ë™

### Milestone 3: í”„ë¡œë•ì…˜ ì¤€ë¹„ (15ì£¼)
- âœ… ì•„í‚¤í…ì²˜ ë¦¬íŒ©í† ë§
- âœ… ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ 80%+
- âœ… HtmlReportService
- âœ… ì„±ëŠ¥ ìµœì í™”
- **ê²°ê³¼**: í”„ë¡œë•ì…˜ ë°°í¬ ê°€ëŠ¥

---

## ë¦¬ìŠ¤í¬ ë° ì™„í™” ì „ëµ

### ë¦¬ìŠ¤í¬ 1: GDAL C# ë°”ì¸ë”© ë³µì¡ë„
**ì™„í™”**:
- ì´ˆê¸° í”„ë¡œí† íƒ€ì…ìœ¼ë¡œ ê¸°ìˆ  ê²€ì¦
- GDAL ì „ë¬¸ê°€ ìë¬¸
- Fallback ì „ëµ ìˆ˜ë¦½

### ë¦¬ìŠ¤í¬ 2: ëŒ€ìš©ëŸ‰ ë°ì´í„° ì²˜ë¦¬ ì„±ëŠ¥
**ì™„í™”**:
- ì´ˆê¸° ì„±ëŠ¥ ë²¤ì¹˜ë§ˆí¬ ìˆ˜ë¦½
- ìŠ¤íŠ¸ë¦¬ë° ì²˜ë¦¬ ìš°ì„  ì ìš©
- ë©”ëª¨ë¦¬ í”„ë¡œíŒŒì¼ë§ ì§€ì†

### ë¦¬ìŠ¤í¬ 3: ë³µì¡í•œ ì†ì„±/ê´€ê³„ ê·œì¹™
**ì™„í™”**:
- ë‹¨ìˆœ ê·œì¹™ë¶€í„° ì ì§„ì  êµ¬í˜„
- ê·œì¹™ë³„ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ í•„ìˆ˜
- CSV ê·œì¹™ ë¬¸ì„œí™” ê°•í™”

---

## ê²°ë¡ 

SpatialCheckProëŠ” **ê²¬ê³ í•œ ì•„í‚¤í…ì²˜ ê¸°ë°˜**ì„ ê°€ì§€ê³  ìˆì§€ë§Œ, **í•µì‹¬ ê²€ì¦ ë¡œì§ì˜ êµ¬í˜„ ì™„ì„±**ì´ í•„ìš”í•©ë‹ˆë‹¤.

### ì¦‰ì‹œ ì¡°ì¹˜ê°€ í•„ìš”í•œ í•­ëª©
1. âœ… SchemaCheckProcessor ì™„ì „ êµ¬í˜„
2. âœ… PDF/Excel ë³´ê³ ì„œ ìƒì„± êµ¬í˜„
3. âœ… ì†ì„±/ê´€ê³„ ê²€ì‚¬ ë¡œì§ ì™„ì„±

### ê¶Œì¥ ì ‘ê·¼ ë°©ì‹
- **Phase 1 (4ì£¼)**: ê¸´ê¸‰ ìˆ˜ì • - ìµœì†Œ í”„ë¡œë•ì…˜ ìš”êµ¬ì‚¬í•­
- **Phase 2 (6ì£¼)**: í•µì‹¬ ê¸°ëŠ¥ ì™„ì„± - ëª¨ë“  ê²€ìˆ˜ ë‹¨ê³„ ì‘ë™
- **Phase 3 (5ì£¼)**: í’ˆì§ˆ ê°œì„  - ìœ ì§€ë³´ìˆ˜ì„± ë° í™•ì¥ì„±

**ì´ ì˜ˆìƒ íˆ¬ì…**: 15ì£¼, 4ëª… ê°œë°œì, 575ì‹œê°„

---

**ë¬¸ì„œ ë**

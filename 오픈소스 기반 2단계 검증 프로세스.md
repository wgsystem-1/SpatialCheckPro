## 오픈소스 기반 2단계 검증 프로세스

ESRI ArcObjects를 배제하고 순수 오픈소스로 FileGDB 검증을 구현하는 방안입니다.

### 1. **GDAL/OGR + NetTopologySuite 조합**

```csharp
using OSGeo.OGR;
using OSGeo.OSR;
using NetTopologySuite.Geometries;
using NetTopologySuite.Operation.Valid;
using NetTopologySuite.Algorithm;

public class OpenSourcePolygonValidator
{
    private readonly PrecisionModel _precisionModel;
    private readonly GeometryFactory _geometryFactory;
    
    public OpenSourcePolygonValidator()
    {
        // FileGDB 정밀도에 맞춤
        _precisionModel = new PrecisionModel(10000000); 
        _geometryFactory = new GeometryFactory(_precisionModel);
        
        // GDAL 초기화
        Ogr.RegisterAll();
    }
    
    public ValidationResult ValidateFileGDBFeatures(string gdbPath, string featureClassName)
    {
        var results = new List<ValidationError>();
        
        // 1차: GDAL/OGR로 FileGDB 직접 읽기
        using (DataSource ds = Ogr.Open(gdbPath, 0))
        {
            Layer layer = ds.GetLayerByName(featureClassName);
            Feature feature;
            
            while ((feature = layer.GetNextFeature()) != null)
            {
                Geometry ogrGeometry = feature.GetGeometryRef();
                
                // 2차: NTS로 변환 후 검증
                var validationResult = ValidateWithNTS(ogrGeometry, feature.GetFID());
                if (!validationResult.IsValid)
                    results.Add(validationResult.Error);
                    
                feature.Dispose();
            }
        }
        
        return new ValidationResult(results);
    }
    
    private ValidationResult ValidateWithNTS(Geometry ogrGeometry, long fid)
    {
        // WKB 변환을 통한 NTS Geometry 생성
        byte[] wkb = ogrGeometry.ExportToWkb();
        var wkbReader = new NetTopologySuite.IO.WKBReader(_geometryFactory);
        var ntsGeometry = wkbReader.Read(wkb);
        
        // 실제 검증 로직
        return PerformOGCValidation(ntsGeometry, fid);
    }
}
```

### 2. **정교한 OGC 검증 구현**

```csharp
public class OGCPolygonValidator
{
    private readonly double _tolerance;
    
    public OGCPolygonValidator(double tolerance = 1e-8)
    {
        _tolerance = tolerance;
    }
    
    public ValidationResult PerformOGCValidation(Geometry geometry, long featureId)
    {
        var errors = new List<string>();
        
        if (geometry is Polygon polygon)
        {
            errors.AddRange(ValidatePolygon(polygon));
        }
        else if (geometry is MultiPolygon multiPolygon)
        {
            for (int i = 0; i < multiPolygon.NumGeometries; i++)
            {
                var poly = (Polygon)multiPolygon.GetGeometryN(i);
                errors.AddRange(ValidatePolygon(poly));
            }
        }
        
        return new ValidationResult
        {
            FeatureId = featureId,
            IsValid = errors.Count == 0,
            Errors = errors
        };
    }
    
    private List<string> ValidatePolygon(Polygon polygon)
    {
        var errors = new List<string>();
        
        // 1. Exterior Ring 검증
        var exterior = polygon.ExteriorRing;
        var extErrors = ValidateLinearRing(exterior, true);
        errors.AddRange(extErrors);
        
        // 2. Interior Rings 검증
        for (int i = 0; i < polygon.NumInteriorRings; i++)
        {
            var interior = polygon.GetInteriorRingN(i);
            var intErrors = ValidateLinearRing(interior, false);
            errors.AddRange(intErrors);
        }
        
        // 3. Topology 검증
        errors.AddRange(ValidatePolygonTopology(polygon));
        
        return errors;
    }
    
    private List<string> ValidateLinearRing(LineString ring, bool isExterior)
    {
        var errors = new List<string>();
        var coords = ring.Coordinates;
        
        // OGC SFS 1.2.1 - 최소 4개 좌표 (첫점과 끝점 포함)
        if (coords.Length < 4)
        {
            errors.Add($"Ring has {coords.Length} points, minimum 4 required");
            return errors;
        }
        
        // 닫힌 링 검사
        if (!IsRingClosed(coords))
        {
            errors.Add("Ring is not closed");
            return errors;
        }
        
        // 실제 고유 정점 검사 (중복 제거)
        var uniqueCoords = GetUniqueCoordinates(coords);
        if (uniqueCoords.Count < 3) // 첫점/끝점 제외 시 최소 3개 고유 정점
        {
            errors.Add($"Ring has only {uniqueCoords.Count} unique vertices");
            return errors;
        }
        
        // Ring Orientation 검사
        bool isCCW = Orientation.IsCCW(coords);
        if (isExterior && !isCCW)
        {
            errors.Add("Exterior ring must be counter-clockwise");
        }
        else if (!isExterior && isCCW)
        {
            errors.Add("Interior ring must be clockwise");
        }
        
        // Self-intersection 검사
        if (HasSelfIntersection(coords))
        {
            errors.Add("Ring has self-intersection");
        }
        
        return errors;
    }
    
    private bool IsRingClosed(Coordinate[] coords)
    {
        var first = coords[0];
        var last = coords[coords.Length - 1];
        
        return Math.Abs(first.X - last.X) < _tolerance &&
               Math.Abs(first.Y - last.Y) < _tolerance;
    }
    
    private HashSet<Coordinate> GetUniqueCoordinates(Coordinate[] coords)
    {
        var unique = new HashSet<Coordinate>(new CoordinateComparer(_tolerance));
        
        // 마지막 점 제외 (첫점과 중복)
        for (int i = 0; i < coords.Length - 1; i++)
        {
            unique.Add(coords[i]);
        }
        
        return unique;
    }
    
    private bool HasSelfIntersection(Coordinate[] coords)
    {
        // 간단한 O(n²) 알고리즘 - 성능 필요시 Bentley-Ottmann 알고리즘 사용
        for (int i = 0; i < coords.Length - 1; i++)
        {
            var seg1 = new LineSegment(coords[i], coords[i + 1]);
            
            for (int j = i + 2; j < coords.Length - 1; j++)
            {
                // 인접 세그먼트는 제외
                if (j == i + 1 || (i == 0 && j == coords.Length - 2))
                    continue;
                    
                var seg2 = new LineSegment(coords[j], coords[j + 1]);
                
                if (seg1.Intersection(seg2) != null)
                    return true;
            }
        }
        
        return false;
    }
}
```

### 3. **좌표 비교 헬퍼 클래스**

```csharp
public class CoordinateComparer : IEqualityComparer<Coordinate>
{
    private readonly double _tolerance;
    
    public CoordinateComparer(double tolerance)
    {
        _tolerance = tolerance;
    }
    
    public bool Equals(Coordinate x, Coordinate y)
    {
        if (x == null || y == null) return false;
        
        return Math.Abs(x.X - y.X) < _tolerance &&
               Math.Abs(x.Y - y.Y) < _tolerance;
    }
    
    public int GetHashCode(Coordinate coord)
    {
        // 정밀도를 고려한 해시코드 생성
        long xHash = (long)(coord.X / _tolerance);
        long yHash = (long)(coord.Y / _tolerance);
        return (xHash * 397) ^ yHash.GetHashCode();
    }
}
```

### 4. **고급 Topology 검증**

```csharp
public class AdvancedTopologyValidator
{
    private readonly IsValidOp _validOp;
    
    public AdvancedTopologyValidator()
    {
        _validOp = new IsValidOp(null);
    }
    
    public List<string> ValidatePolygonTopology(Polygon polygon)
    {
        var errors = new List<string>();
        
        // NTS의 IsValidOp 활용
        _validOp.SelfTouchingRingFormingHoleValid = false; // OGC strict
        
        if (!_validOp.IsValid(polygon))
        {
            var error = _validOp.ValidationError;
            errors.Add($"{error.ErrorType}: {error.Message} at {error.Coordinate}");
        }
        
        // 추가 검증: Ring 간 관계
        var exterior = polygon.ExteriorRing;
        
        for (int i = 0; i < polygon.NumInteriorRings; i++)
        {
            var interior = polygon.GetInteriorRingN(i);
            
            // Interior ring이 exterior 내부에 있는지 검증
            if (!IsRingInsideRing(interior, exterior))
            {
                errors.Add($"Interior ring {i} is not inside exterior ring");
            }
            
            // Interior rings 간 교차 검증
            for (int j = i + 1; j < polygon.NumInteriorRings; j++)
            {
                var otherInterior = polygon.GetInteriorRingN(j);
                if (RingsIntersect(interior, otherInterior))
                {
                    errors.Add($"Interior rings {i} and {j} intersect");
                }
            }
        }
        
        return errors;
    }
    
    private bool IsRingInsideRing(LineString inner, LineString outer)
    {
        var innerPoly = new GeometryFactory().CreatePolygon(inner.Coordinates);
        var outerPoly = new GeometryFactory().CreatePolygon(outer.Coordinates);
        
        return outerPoly.Contains(innerPoly);
    }
    
    private bool RingsIntersect(LineString ring1, LineString ring2)
    {
        var poly1 = new GeometryFactory().CreatePolygon(ring1.Coordinates);
        var poly2 = new GeometryFactory().CreatePolygon(ring2.Coordinates);
        
        return poly1.Intersects(poly2);
    }
}
```

### 5. **Windows UI 통합 예제**

```csharp
// WPF 또는 WinForms에서 사용
public class ValidationUI
{
    private readonly OpenSourcePolygonValidator _validator;
    
    public async Task<ValidationReport> ValidateFileGDBAsync(
        string gdbPath, 
        string featureClass,
        IProgress<int> progress)
    {
        return await Task.Run(() =>
        {
            var validator = new OpenSourcePolygonValidator();
            var results = validator.ValidateFileGDBFeatures(gdbPath, featureClass);
            
            // UI 업데이트
            progress?.Report(results.ProcessedCount);
            
            return results;
        });
    }
}
```

## 핵심 포인트

1. **GDAL/OGR**로 FileGDB 직접 읽기 (ESRI 라이선스 불필요)
2. **NetTopologySuite**로 OGC 표준 준수 검증
3. **정밀도 관리**: FileGDB의 XY Tolerance와 일치하도록 설정
4. **중복 정점 제거** 후 실제 고유 정점 수 확인
5. **Ring Orientation** 명확한 검증 (Exterior: CCW, Interior: CW)
6. **Self-intersection** 검사로 위상 오류 검출

이 방식으로 ESRI 종속성 없이 정확한 OGC 검증이 가능합니다.
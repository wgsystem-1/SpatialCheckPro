**현행(검수 대상 GDB 내부 저장)** → **별도 QC용 GDB 저장**으로 바꾸되, **동일 경로에 `검수파일명_QC_yymmddhhmmss.gdb` 생성**하고 그 안에만 쓰도록 리팩터링한 **구체 변경안 + 코드 스켈레톤**을 드립니다.
 (요구사항: **SHP 저장 없음**, **오픈소스 GDAL/OGR**, **C#/.NET**, **Windows UI**)

------

# 변경 포인트 요약

1. **저장 위치 결정 로직**을 중앙집중화: 대상 GDB 경로를 받으면 **동일 폴더**에 `원본이름_QC_yymmddhhmmss.gdb` 생성.
2. **별도 QC GDB에 스키마 보장**: `QC_Runs`, `QC_Errors_Point/Line/Polygon/NoGeom` 생성/재사용.
3. **RunID 일관 유지**: `QcRun` 생성→반환된 `RunID`를 오류 적재 시 공통키로 사용.
4. **SHP 경로/Export 로직 전면 제거**(또는 비활성화).
5. **서비스 경계 유지**: UI/검수엔진 변경 최소화. `FgdbSchemaService`, `QcErrorDataService`, `QcErrorService`에 주입되는 **저장소 인터페이스**만 교체.

------

# 신규/수정 파일 구조(제안)

```
G:\SpatialCheckPro\SpatialCheckPro\
  Services\
    FgdbSchemaService.cs           // (수정) QC 스키마 생성 대상 = 외부 QC.gdb
    QcErrorDataService.cs          // (수정) Insert 대상 = 외부 QC.gdb
    QcErrorService.cs              // (수정) Run 생성/요약 업데이트 = 외부 QC.gdb
    QcStoragePathService.cs        // (신규) QC.gdb 경로/생성명 규칙
    QcGdbSink.cs                   // (신규) GDAL/OGR OpenFileGDB 기반 공통 Sink
  Models\
    QcRun.cs                       // (변경 없음, RunID/요약 필드 재사용)
    QcError.cs                     // (변경 없음, 공통 오류 스키마 재사용)
SpatialCheckPro.GUI\
  Services\
    SimpleValidationService.cs     // (수정) 대상GDB→QC.gdb 경로 요청/RunID 전달
```

------

# 1) QC 저장 경로 생성 서비스 (신규)

**`QcStoragePathService.cs`**

```csharp
using System;
using System.IO;

namespace SpatialCheckPro.Services
{
    public static class QcStoragePathService
    {
        // 입력: 검수 대상 FileGDB 경로 (예: D:\work\검수filegdb.gdb)
        // 출력: 동일 폴더의 QC용 GDB (예: D:\work\검수filegdb_QC_251016073000.gdb)
        public static string BuildQcGdbPath(string targetGdbPathUtc)
        {
            if (string.IsNullOrWhiteSpace(targetGdbPathUtc))
                throw new ArgumentException("Target GDB path is empty.");

            var dir = Path.GetDirectoryName(targetGdbPathUtc) ?? ".";
            var name = Path.GetFileNameWithoutExtension(targetGdbPathUtc);
            var ts = DateTime.UtcNow.ToString("yyMMddHHmmss"); // 요구: yymmddhhmmss (UTC 권장)
            var qcName = $"{name}_QC_{ts}.gdb";
            return Path.Combine(dir, qcName);
        }
    }
}
```

> ※ 로컬시간 기준을 원하시면 `DateTime.Now`로 바꾸세요.

------

# 2) GDAL/OGR 기반 QC 전용 Sink (신규)

**`QcGdbSink.cs`** — **오픈소스 OpenFileGDB**로 생성/쓰기. (Esri SDK 불필요)

```csharp
using System;
using System.IO;
using OSGeo.OGR;
using OSGeo.GDAL;

namespace SpatialCheckPro.Services
{
    public class QcGdbSink : IDisposable
    {
        private readonly string _qcGdbPath;
        private DataSource _ds;
        private Layer _runsTbl, _ptLyr, _lnLyr, _pgLyr, _noGeomTbl;

        public QcGdbSink(string qcGdbPath)
        {
            _qcGdbPath = qcGdbPath ?? throw new ArgumentNullException(nameof(qcGdbPath));
        }

        public void OpenOrCreate()
        {
            Gdal.AllRegister();
            Ogr.RegisterAll();
            var drv = Ogr.GetDriverByName("OpenFileGDB");
            if (drv == null) throw new InvalidOperationException("OpenFileGDB driver not found.");

            // gdb 폴더 생성
            if (!Directory.Exists(_qcGdbPath)) Directory.CreateDirectory(_qcGdbPath);

            // 열기(쓰기) 또는 생성
            _ds = drv.Open(_qcGdbPath, 1) ?? drv.CreateDataSource(_qcGdbPath, null);
            if (_ds == null) throw new InvalidOperationException($"Cannot open/create QC GDB: {_qcGdbPath}");

            EnsureSchemas();
        }

        public void EnsureSchemas()
        {
            // 1) QC_Runs 테이블
            _runsTbl = EnsureTable("QC_Runs", QcSchemas.RunsFields());
            // 2) 오류 피처/테이블
            _ptLyr = EnsureFc("QC_Errors_Point", wkbGeometryType.wkbPoint, QcSchemas.ErrorFields());
            _lnLyr = EnsureFc("QC_Errors_Line", wkbGeometryType.wkbLineString, QcSchemas.ErrorFields());
            _pgLyr = EnsureFc("QC_Errors_Polygon", wkbGeometryType.wkbPolygon, QcSchemas.ErrorFields());
            _noGeomTbl = EnsureTable("QC_Errors_NoGeom", QcSchemas.ErrorFields());
        }

        private Layer EnsureTable(string name, FieldDefn[] fields)
        {
            var lyr = _ds.GetLayerByName(name);
            if (lyr != null) return lyr;
            var def = new LayerDefn(name);
            lyr = _ds.CreateLayer(name, null, wkbGeometryType.wkbNone, null);
            foreach (var f in fields) lyr.CreateField(f, 0);
            return lyr;
        }

        private Layer EnsureFc(string name, wkbGeometryType gType, FieldDefn[] fields)
        {
            var lyr = _ds.GetLayerByName(name);
            if (lyr != null) return lyr;
            lyr = _ds.CreateLayer(name, null, gType, null);
            foreach (var f in fields) lyr.CreateField(f, 0);
            return lyr;
        }

        // --- Run 생성/업데이트 ---
        public string CreateRun(Models.QcRun run)
        {
            var runId = Guid.NewGuid().ToString();
            var f = new Feature(_runsTbl.GetLayerDefn());
            f.SetField("RunID", runId);
            f.SetField("RunName", run.RunName ?? "");
            f.SetField("TargetPath", run.TargetFilePath ?? "");
            f.SetField("RulesetVer", run.RulesetVersion ?? "");
            f.SetField("StartUTC", DateTime.UtcNow.ToString("o"));
            f.SetField("Status", "Running");
            _runsTbl.CreateFeature(f);
            f.Dispose();
            _ds.FlushCache();
            return runId;
        }

        public void UpdateRunSummary(string runId, int totalErrors, int totalWarnings, string summary, bool success = true)
        {
            // 간단 구현: RunID=runId 레코드 찾기 → 갱신
            _runsTbl.ResetReading();
            Feature f;
            while ((f = _runsTbl.GetNextFeature()) != null)
            {
                if (string.Equals(f.GetFieldAsString("RunID"), runId, StringComparison.OrdinalIgnoreCase))
                {
                    f.SetField("EndUTC", DateTime.UtcNow.ToString("o"));
                    f.SetField("Status", success ? "Completed" : "Failed");
                    f.SetField("ErrCnt", totalErrors);
                    f.SetField("WarnCnt", totalWarnings);
                    f.SetField("Summary", summary ?? "");
                    _runsTbl.SetFeature(f);
                    f.Dispose();
                    _ds.FlushCache();
                    return;
                }
                f.Dispose();
            }
        }

        // --- 오류 적재 ---
        public void AddError(Models.QcError e)
        {
            Layer lyr = e.GeometryType?.ToUpperInvariant() switch
            {
                "POINT"      => _ptLyr,
                "LINESTRING" => _lnLyr,
                "POLYGON"    => _pgLyr,
                _            => _noGeomTbl
            };

            var f = new Feature(lyr.GetLayerDefn());
            f.SetField("RunID", e.RunID ?? "");
            f.SetField("ErrType", e.ErrType ?? "");
            f.SetField("ErrCode", e.ErrCode ?? "");
            f.SetField("Severity", e.Severity ?? "");
            f.SetField("RuleID", e.RuleID ?? "");
            f.SetField("SourceClass", e.SourceClass ?? "");
            f.SetField("SourceOID", e.SourceOID);
            f.SetField("Message", e.Message ?? "");
            f.SetField("CheckedUTC", DateTime.UtcNow.ToString("o"));

            // 지오메트리 설정(선택: e.Wkt or 좌표 리스트)
            if (lyr != _noGeomTbl && !string.IsNullOrWhiteSpace(e.Wkt))
            {
                using var g = Ogr.CreateGeometryFromWkt(e.Wkt);
                f.SetGeometry(g);
            }

            lyr.CreateFeature(f);
            f.Dispose();
        }

        public void Flush() => _ds?.FlushCache();
        public void Dispose() => _ds?.Dispose();
    }

    internal static class QcSchemas
    {
        public static FieldDefn[] RunsFields() => new[]
        {
            new FieldDefn("RunID", FieldType.OFTString) { SetWidth(36) },
            new FieldDefn("RunName", FieldType.OFTString) { SetWidth(128) },
            new FieldDefn("TargetPath", FieldType.OFTString) { SetWidth(254) },
            new FieldDefn("RulesetVer", FieldType.OFTString) { SetWidth(32) },
            new FieldDefn("StartUTC", FieldType.OFTString) { SetWidth(32) },
            new FieldDefn("EndUTC", FieldType.OFTString) { SetWidth(32) },
            new FieldDefn("Status", FieldType.OFTString) { SetWidth(16) },
            new FieldDefn("ErrCnt", FieldType.OFTInteger),
            new FieldDefn("WarnCnt", FieldType.OFTInteger),
            new FieldDefn("Summary", FieldType.OFTString) { SetWidth(254) }
        };

        public static FieldDefn[] ErrorFields() => new[]
        {
            new FieldDefn("RunID", FieldType.OFTString) { SetWidth(36) },
            new FieldDefn("ErrType", FieldType.OFTString) { SetWidth(24) },
            new FieldDefn("ErrCode", FieldType.OFTString) { SetWidth(24) },
            new FieldDefn("Severity", FieldType.OFTString) { SetWidth(8) },
            new FieldDefn("RuleID", FieldType.OFTString) { SetWidth(64) },
            new FieldDefn("SourceClass", FieldType.OFTString) { SetWidth(64) },
            new FieldDefn("SourceOID", FieldType.OFTInteger),
            new FieldDefn("Message", FieldType.OFTString) { SetWidth(254) },
            new FieldDefn("CheckedUTC", FieldType.OFTString) { SetWidth(32) }
        };
    }
}
```

> 위 필드명은 사용 중인 `QcRun`, `QcError`와 최대한 호환되게 잡았습니다. 필요 시 타입/길이만 조정하세요.

------

# 3) 기존 서비스 수정 지점

## 3.1 `FgdbSchemaService.cs` (수정)

- **이전**: “대상 GDB 내부”에 QC 스키마 생성
- **이후**: **`QcStoragePathService.BuildQcGdbPath(target)`로 QC.gdb 결정 → `QcGdbSink.OpenOrCreate()` 호출**로 스키마 보장.
- **반환값**: QC.gdb 경로(또는 `QcGdbSink` 인스턴스)를 상위로 전달.

```csharp
// FgdbSchemaService.cs (핵심 변경부 예시)
public class FgdbSchemaService
{
    public string EnsureQcSchemasAtExternalGdb(string targetGdbPath)
    {
        var qcGdb = QcStoragePathService.BuildQcGdbPath(targetGdbPath);
        using var sink = new QcGdbSink(qcGdb);
        sink.OpenOrCreate();     // 내부에서 QC_Runs, QC_Errors_* 보장
        return qcGdb;
    }
}
```

## 3.2 `QcErrorService.cs` (수정)

- **Run 생성·요약 업데이트**를 **외부 QC.gdb**에서 처리.
- **RunID**를 멤버로 들고, 오류 적재 서비스에 전달.

```csharp
public class QcErrorService
{
    private readonly FgdbSchemaService _schema;
    private string _qcGdbPath;
    private string _currentRunId;

    public QcErrorService(FgdbSchemaService schema) => _schema = schema;

    public (string qcGdbPath, string runId) BeginRun(Models.QcRun run, string targetGdbPath)
    {
        _qcGdbPath = _schema.EnsureQcSchemasAtExternalGdb(targetGdbPath);
        using var sink = new QcGdbSink(_qcGdbPath);
        sink.OpenOrCreate();
        _currentRunId = sink.CreateRun(run);
        return (_qcGdbPath, _currentRunId);
    }

    public void EndRun(int totalErrors, int totalWarnings, string summary, bool success=true)
    {
        using var sink = new QcGdbSink(_qcGdbPath);
        sink.OpenOrCreate();
        sink.UpdateRunSummary(_currentRunId, totalErrors, totalWarnings, summary, success);
        sink.Flush();
    }

    public string CurrentRunId => _currentRunId;
    public string CurrentQcGdb => _qcGdbPath;
}
```

## 3.3 `QcErrorDataService.cs` (수정)

- **Insert 대상**을 **외부 QC.gdb**로 변경.
- `QcErrorService.CurrentRunId`, `CurrentQcGdb`를 받아 오류 단건/배치 적재.

```csharp
public class QcErrorDataService
{
    public void InsertErrors(string qcGdbPath, IEnumerable<Models.QcError> errors, string runId)
    {
        using var sink = new QcGdbSink(qcGdbPath);
        sink.OpenOrCreate();
        foreach (var e in errors)
        {
            e.RunID = runId;
            sink.AddError(e);
        }
        sink.Flush();
    }
}
```

## 3.4 `SimpleValidationService.cs` (GUI/엔트리포인트 수정)

- 대상 GDB 선택 → **`BeginRun()` 호출 → 검수 실행 → **오류는 `InsertErrors()`로 외부 QC.gdb에 저장** → `EndRun()`.

```csharp
public class SimpleValidationService
{
    private readonly QcErrorService _errSvc;
    private readonly QcErrorDataService _dataSvc;

    public SimpleValidationService(QcErrorService errSvc, QcErrorDataService dataSvc)
    {
        _errSvc = errSvc;
        _dataSvc = dataSvc;
    }

    public void ExecuteAll(string targetGdbPath, string rulesCsv)
    {
        var (qcGdb, runId) = _errSvc.BeginRun(new Models.QcRun {
            RunName = "Spatial QC",
            TargetFilePath = targetGdbPath,
            RulesetVersion = "1.0.0"
        }, targetGdbPath);

        int errCnt = 0, warnCnt = 0;
        try
        {
            foreach (var batch in QcEngine.RunBySteps(targetGdbPath, rulesCsv)) // 규칙 단계별 실행(기존 로직 재사용)
            {
                _dataSvc.InsertErrors(qcGdb, batch.Errors, runId);
                errCnt += batch.Errors.Count(e => e.Severity == "CRIT" || e.Severity == "MAJOR");
                warnCnt += batch.Errors.Count(e => e.Severity == "MINOR" || e.Severity == "WARN");
            }
            _errSvc.EndRun(errCnt, warnCnt, "Completed", success:true);
        }
        catch (Exception ex)
        {
            _errSvc.EndRun(errCnt, warnCnt, $"Failed: {ex.Message}", success:false);
            throw;
        }
    }
}
```

> `QcEngine.RunBySteps`는 기존 단계별 CSV 규칙 실행 루틴을 의미(그대로 사용).

------

# 4) 모델 (`QcRun.cs`, `QcError.cs`)

- **변경 없음**(RunID/공통필드 그대로).
- 지오메트리는 기존처럼 **WKT/좌표열** 중 프로젝트 표준에 맞춰 세팅.

------

# 5) 동작 흐름(요약)

1. 사용자가 **검수 대상 GDB** 선택 → `target.gdb`
2. `QcStoragePathService` → **`target_QC_yymmddhhmmss.gdb` 경로 생성**
3. `QcGdbSink.OpenOrCreate()` → **QC 스키마 보장**
4. `QcErrorService.BeginRun()` → **RunID 발급 및 기록(QC_Runs)**
5. 규칙 단계별 실행 → **오류는 모두 QC.gdb의 `QC_Errors_\*`에 적재**
6. 종료 시 `EndRun()` → **요약/상태 업데이트**

> **SHP는 생성/저장하지 않음**(요구사항 반영).

------

# 6) 테스트 체크리스트

- **경로/명명**: QC.gdb가 **동일 폴더**, 이름이 `원본파일명_QC_YYMMDDHHMMSS.gdb`로 생성되는지.
- **스키마**: `QC_Runs`, `QC_Errors_Point/Line/Polygon/NoGeom` 자동 생성 확인.
- **런 결속**: `QC_Runs.RunID`와 오류 레코드 `RunID` 일치.
- **대량 적재 성능**: 10만 건 이상 배치 시 `Flush()` 타이밍 조정으로 속도 확인.
- **예외 처리**: 생성 실패/디스크 부족/잠금 발생 시 `EndRun(Failed)` 로 마무리.
- **UTC 타임스탬프**: 일관된 시간대 기록(감사/재현성 강화).

------

# 마무리

위 변경안은 **현 서비스 레이어 구조를 유지**한 채 **저장소만 외부 QC.gdb로 전환**합니다.
 원하시면, 위 스켈레톤을 **실제 프로젝트 네임스페이스/필드 스펙**에 맞춰 **완전체 코드**로 정리해서 드릴게요.
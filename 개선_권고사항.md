# SpatialCheckPro 개선 권고사항

**문서 버전**: 1.0
**작성일**: 2025-10-21
**분석 기준**: 코드베이스 전체 분석 결과

---

## 📋 목차

1. [개요](#개요)
2. [현재 구현 상태 요약](#현재-구현-상태-요약)
3. [치명적 누락 (Critical Gaps)](#치명적-누락-critical-gaps)
4. [개선 우선순위](#개선-우선순위)
5. [상세 개선 계획](#상세-개선-계획)
6. [아키텍처 개선 권고](#아키텍처-개선-권고)
7. [테스트 전략](#테스트-전략)
8. [예상 일정 및 리소스](#예상-일정-및-리소스)

---

## 개요

### 분석 결과 요약

SpatialCheckPro 프로젝트는 **견고한 아키텍처**를 가지고 있지만, **핵심 비즈니스 로직의 구현이 불완전**합니다.

- **전체 구현률**: 56% (13개 주요 컴포넌트 중 8개 완성)
- **문서와 실제 구현 일치율**: 56%
- **프로덕션 준비도**: 낮음 (치명적 누락 5건)

### 주요 발견사항

#### 강점
- ✅ 명확한 계층 분리 및 MVVM 패턴 적용
- ✅ DI 기반 느슨한 결합
- ✅ 견고한 오케스트레이션 로직
- ✅ FileGDB 무결성 검사 완성도 높음
- ✅ 지오메트리 검사 로직 우수

#### 약점
- ❌ 고성능 모드 (GDB→SQLite) 미구현
- ❌ 스키마 검사 Processor stub 상태
- ❌ 보고서 생성 기능 미구현
- ⚠️ 속성/관계 검사 로직 불완전
- ⚠️ 문서와 실제 구현 간 괴리

---

## 현재 구현 상태 요약

### 데이터 흐름별 완성도

| 단계 | 컴포넌트 | 완성도 | 상태 | 치명도 |
|-----|---------|-------|------|--------|
| 1 | 파일 선택 | 100% | ✅ 완성 | - |
| 2 | CSV 설정 로드 | 100% | ✅ 완성 | - |
| 3 | **GDB→SQLite 변환** | **0%** | ❌ Stub | 🔴 치명적 |
| 4 | 오케스트레이션 (SimpleValidationService) | 95% | ✅ 거의 완성 | - |
| 5-0 | Stage 0: FileGDB 무결성 검사 | 100% | ✅ 완성 | - |
| 5-1 | Stage 1: 테이블 검사 | 100% | ✅ 완성 | - |
| 5-2 | **Stage 2: 스키마 검사** | **5%** | ❌ Stub | 🔴 치명적 |
| 5-3 | Stage 3: 지오메트리 검사 | 90% | ✅ 거의 완성 | - |
| 5-4 | **Stage 4: 속성 검사** | **40%** | ⚠️ 불완전 | 🟡 중요 |
| 5-5 | **Stage 5: 관계 검사** | **40%** | ⚠️ 불완전 | 🟡 중요 |
| 6 | QC Error 생성 및 저장 | 90% | ✅ 거의 완성 | - |
| 7 | 검수 결과 집계 | 100% | ✅ 완성 | - |
| 8 | **보고서 생성 (PDF/Excel/HTML)** | **5%** | ❌ Stub | 🔴 치명적 |

---

## 치명적 누락 (Critical Gaps)

### 🔴 Gap #1: GdbToSqliteConverter 미구현

**위치**: `SpatialCheckPro/Services/GdbToSqliteConverter.cs`
**현재 상태**: 완전 stub

#### 문제 코드
```csharp
// Line 72-81
private void CopyLayerToSqlite(Layer layer, SqliteConnection connection)
{
    // 이 부분은 OGR의 C# 바인딩과 SpatiaLite SQL을 사용하여 구현해야 합니다.
    // 시간 관계상 상세 구현은 생략하고 개념적인 코드로 대체합니다.
    _logger.LogInformation("레이어 복사 중: {LayerName}", layer.GetName());

    // 1. 테이블 생성 SQL 생성
    // 2. 피처를 하나씩 읽어 INSERT SQL 실행
    //    - 지오메트리는 ST_GeomFromWKB() 함수 사용
}
```

#### 영향
- 고성능 모드 활성화 시 **빈 SQLite DB** 생성
- 이후 모든 검수가 빈 데이터베이스 대상으로 진행
- 사용자는 "검수 완료"라고 보지만 실제로는 아무 검사도 이루어지지 않음

#### 필요 작업
1. GDAL Layer 스키마 분석 및 SQLite DDL 생성
2. Feature 단위 반복 처리 및 INSERT 구현
3. 지오메트리 WKB 변환 및 SpatiaLite 함수 활용
4. 배치 처리 및 트랜잭션 관리
5. 진행률 보고 통합

**예상 작업 시간**: 40-60시간

---

### 🔴 Gap #2: SchemaCheckProcessor 미구현

**위치**: `SpatialCheckPro/Processors/SchemaCheckProcessor.cs`
**현재 상태**: 완전 stub

#### 문제 코드
```csharp
public async Task<ValidationResult> ProcessAsync(
    string filePath,
    SchemaCheckConfig config,
    CancellationToken cancellationToken = default)
{
    _logger.LogInformation("스키마 검수 시작: {FilePath}", filePath);
    await Task.Delay(100, cancellationToken);

    return new ValidationResult
    {
        IsValid = true,
        Message = "스키마 검수 완료 (임시 구현)"
    };
}
```

#### 영향
- Stage 2 스키마 검사가 **항상 통과**
- 컬럼 구조, 데이터 타입, PK/FK 검증 전혀 이루어지지 않음
- 잘못된 스키마를 가진 데이터가 그대로 통과

#### 필요 작업
1. GDAL/OGR을 통한 실제 스키마 읽기
2. `2_schema_check.csv` 규칙과 비교 로직 구현
3. 컬럼 존재 여부 검증
4. 데이터 타입 일치 검증
5. PK/FK 제약조건 검증
6. Null 허용 여부 검증
7. 오류 생성 및 QcError 변환

**예상 작업 시간**: 30-40시간

---

### 🔴 Gap #3: ReportService 전체 미구현

**위치**: `SpatialCheckPro/Services/ReportService.cs` 외 3개
**현재 상태**: 완전 stub

#### 문제 코드
```csharp
public async Task<bool> GenerateReportAsync(
    IEnumerable<ValidationResult> results,
    string outputPath,
    ReportFormat format,
    CancellationToken cancellationToken = default)
{
    _logger.LogInformation("보고서 생성 시작: {Format}, {OutputPath}", format, outputPath);
    await Task.Delay(100, cancellationToken);

    // 간단한 텍스트 보고서 생성
    var content = $"검수 보고서\n생성 시간: {DateTime.Now}\n결과 수: {results.Count()}";
    await System.IO.File.WriteAllTextAsync(outputPath, content, cancellationToken);

    return true;
}
```

#### 영향
- PDF, Excel, HTML 보고서 전혀 생성 안됨
- 단순 텍스트 파일만 생성
- 문서에 명시된 핵심 기능 중 하나가 완전 누락

#### 필요 작업

##### 3-1. PdfReportService 구현
- iTextSharp 라이브러리 활용
- 표지 페이지 생성
- 요약 정보 테이블
- 단계별 검수 결과 섹션
- 오류 목록 테이블
- 통계 차트 (pie/bar chart)

**예상 시간**: 40-50시간

##### 3-2. ExcelReportService 구현
- EPPlus 라이브러리 활용
- 요약 시트 생성
- 단계별 상세 시트 생성
- 오류 목록 시트
- 통계 차트 추가
- 셀 스타일링 및 포맷팅

**예상 시간**: 30-40시간

##### 3-3. HtmlReportService 구현
- Chart.js 통합
- 반응형 HTML 템플릿
- 인터랙티브 차트
- 필터링/정렬 기능
- CSS 스타일링

**예상 시간**: 30-40시간

---

### 🟡 Gap #4: AttributeCheckProcessor 불완전

**위치**: `SpatialCheckPro/Processors/AttributeCheckProcessor.cs`
**현재 상태**: 40% 구현

#### 구현된 부분
- ✅ Codelist 로딩 (28-75행)
- ✅ 필드 인덱스 조회 유틸리티

#### 미구현 부분
- ❌ ValidateAsync() 핵심 검증 로직
- ❌ 93개 속성 관계 규칙 처리
- ❌ ConditionalRuleEngine 통합
- ❌ ExpressionEngine 기반 복잡한 규칙 평가

#### 필요 작업
1. `4_attribute_check.csv` 규칙 파싱 및 로딩
2. 각 피처에 대한 속성 값 추출
3. 규칙별 조건 평가 (ConditionalRuleEngine 활용)
4. 복잡한 표현식 평가 (ExpressionEngine 활용)
5. 위반 사항 검출 및 ValidationError 생성
6. 배치 처리 및 성능 최적화

**예상 작업 시간**: 50-60시간

---

### 🟡 Gap #5: RelationCheckProcessor 불완전

**위치**: `SpatialCheckPro/Processors/RelationCheckProcessor.cs`
**현재 상태**: 40% 구현

#### 구현된 부분
- ✅ 진행률 이벤트 핸들링
- ✅ 캐시 관리 구조

#### 미구현 부분
- ❌ ProcessAsync() 핵심 검증 로직
- ❌ 20개 공간 관계 규칙 처리
- ❌ Case1/Case2/Case3 분기 로직
- ❌ 공간 인덱스 활용한 효율적 쿼리

#### 필요 작업
1. `5_relation_check.csv` 규칙 파싱 및 로딩
2. 공간 관계 타입별 검사 로직 구현
   - Case1: Contains, Within, Intersects 등
   - Case2: Buffer 기반 관계 검사
   - Case3: Topology 기반 관계 검사
3. SpatialIndexManager 통합 (R-Tree/Quad-Tree)
4. 대용량 데이터 처리를 위한 병렬화
5. 위반 사항 검출 및 ValidationError 생성

**예상 작업 시간**: 50-60시간

---

## 개선 우선순위

### 우선순위 1 (즉시 조치 필요 - Critical)

프로덕션 사용을 위한 **최소 필수 요구사항**

| 순위 | 컴포넌트 | 이유 | 예상 시간 |
|-----|---------|------|----------|
| **P1-1** | SchemaCheckProcessor | Stage 2가 항상 통과되어 데이터 품질 보장 불가 | 30-40h |
| **P1-2** | PdfReportService | 검수 결과 공유/보관 불가 | 40-50h |
| **P1-3** | ExcelReportService | 데이터 분석 및 2차 가공 불가 | 30-40h |

**소계**: 100-130시간

---

### 우선순위 2 (단기 조치 - Important)

핵심 기능 완성을 위한 **중요 요구사항**

| 순위 | 컴포넌트 | 이유 | 예상 시간 |
|-----|---------|------|----------|
| **P2-1** | AttributeCheckProcessor | 93개 속성 규칙 검증 누락 | 50-60h |
| **P2-2** | RelationCheckProcessor | 20개 공간 관계 규칙 검증 누락 | 50-60h |
| **P2-3** | GdbToSqliteConverter | 고성능 모드 미작동 (대용량 처리 불가) | 40-60h |

**소계**: 140-180시간

---

### 우선순위 3 (장기 개선 - Enhancement)

품질 및 유지보수성 향상

| 순위 | 컴포넌트 | 이유 | 예상 시간 |
|-----|---------|------|----------|
| **P3-1** | 아키텍처 리팩토링 | Reflection 기반 로직 제거, 코드 중복 제거 | 30-40h |
| **P3-2** | 단위 테스트 구축 | 품질 보증 및 회귀 방지 | 60-80h |
| **P3-3** | HtmlReportService | 인터랙티브 보고서 제공 | 30-40h |
| **P3-4** | 성능 최적화 | 병렬 처리 실제 효과 검증 및 개선 | 20-30h |
| **P3-5** | 문서 동기화 | 실제 구현과 문서 일치화 | 10-15h |

**소계**: 150-205시간

---

## 상세 개선 계획

### P1-1: SchemaCheckProcessor 완전 구현

#### 목표
`2_schema_check.csv` 규칙에 기반하여 실제 스키마 검증 수행

#### 구현 단계

##### 1단계: GDAL 스키마 읽기 (8h)
```csharp
private async Task<TableSchema> ReadActualSchemaAsync(
    string gdbPath,
    string tableName)
{
    using var dataSource = Gdal.OpenEx(gdbPath, 0, null, null, null);
    var layer = dataSource.GetLayerByName(tableName);
    var layerDefn = layer.GetLayerDefn();

    var schema = new TableSchema { TableName = tableName };

    for (int i = 0; i < layerDefn.GetFieldCount(); i++)
    {
        var fieldDefn = layerDefn.GetFieldDefn(i);
        schema.Fields.Add(new FieldSchema
        {
            Name = fieldDefn.GetName(),
            Type = MapOgrTypeToStandardType(fieldDefn.GetFieldType()),
            Width = fieldDefn.GetWidth(),
            Precision = fieldDefn.GetPrecision(),
            IsNullable = fieldDefn.IsNullable()
        });
    }

    return schema;
}
```

##### 2단계: CSV 규칙과 비교 (10h)
```csharp
private List<ValidationError> CompareSchemas(
    TableSchema actual,
    SchemaCheckConfig expected)
{
    var errors = new List<ValidationError>();

    // 컬럼 존재 여부 검증
    foreach (var expectedField in expected.RequiredFields)
    {
        if (!actual.Fields.Any(f => f.Name == expectedField.Name))
        {
            errors.Add(new ValidationError
            {
                ErrorCode = "SCH001",
                Severity = ErrorSeverity.Critical,
                Message = $"필수 컬럼 누락: {expectedField.Name}"
            });
        }
    }

    // 데이터 타입 검증
    foreach (var field in actual.Fields)
    {
        var expected = expected.RequiredFields
            .FirstOrDefault(f => f.Name == field.Name);
        if (expected != null && field.Type != expected.Type)
        {
            errors.Add(new ValidationError
            {
                ErrorCode = "SCH002",
                Severity = ErrorSeverity.Major,
                Message = $"데이터 타입 불일치: {field.Name} (기대: {expected.Type}, 실제: {field.Type})"
            });
        }
    }

    return errors;
}
```

##### 3단계: PK/FK 검증 (12h)
```csharp
private async Task<List<ValidationError>> ValidatePrimaryKeyAsync(
    Layer layer,
    SchemaCheckConfig config)
{
    var errors = new List<ValidationError>();
    var pkField = config.PrimaryKeyField;

    var pkValues = new HashSet<object>();
    layer.ResetReading();

    while (layer.GetNextFeature() is Feature feature)
    {
        var pkValue = feature.GetFieldAsString(pkField);

        if (string.IsNullOrEmpty(pkValue))
        {
            errors.Add(new ValidationError
            {
                ErrorCode = "SCH003",
                Severity = ErrorSeverity.Critical,
                Message = $"PK NULL 값 발견: OID={feature.GetFID()}"
            });
        }
        else if (!pkValues.Add(pkValue))
        {
            errors.Add(new ValidationError
            {
                ErrorCode = "SCH004",
                Severity = ErrorSeverity.Critical,
                Message = $"PK 중복 값 발견: {pkValue}"
            });
        }
    }

    return errors;
}
```

##### 4단계: QcError 변환 및 저장 (5h)
```csharp
private QcError ConvertToQcError(ValidationError error, string runId)
{
    return new QcError
    {
        GlobalID = Guid.NewGuid().ToString(),
        ErrType = "SCHEMA",
        ErrCode = error.ErrorCode,
        Severity = MapSeverity(error.Severity),
        Status = "OPEN",
        RuleId = error.RuleId,
        SourceClass = error.TableName,
        SourceOID = error.FeatureId,
        Message = error.Message,
        RunID = runId,
        X = 0,
        Y = 0
    };
}
```

##### 5단계: 통합 및 테스트 (5h)

**총 예상 시간**: 40시간

---

### P1-2 & P1-3: PDF/Excel ReportService 구현

#### 목표
검수 결과를 전문적인 형식의 보고서로 생성

#### 공통 보고서 구조
```
1. 표지
   - 제목: "공간데이터 검수 보고서"
   - 검수 대상 파일
   - 검수 일시
   - 검수자 정보

2. 요약 (Executive Summary)
   - 전체 검수 결과 (통과/실패)
   - 총 오류 수
   - 심각도별 오류 분포
   - 단계별 결과 요약

3. 단계별 상세 결과
   - Stage 0: FileGDB 무결성 검사
   - Stage 1: 테이블 검사
   - Stage 2: 스키마 검사
   - Stage 3: 지오메트리 검사
   - Stage 4: 속성 검사
   - Stage 5: 공간 관계 검사

4. 오류 목록
   - 테이블별 오류 그룹화
   - 심각도별 정렬
   - 상세 오류 정보

5. 통계 및 차트
   - 오류 유형별 분포 (Pie Chart)
   - 단계별 오류 수 (Bar Chart)
   - 심각도별 분포 (Pie Chart)
```

#### PDF 구현 상세

##### PdfReportService.cs 구조
```csharp
public class PdfReportService
{
    private readonly ILogger<PdfReportService> _logger;

    public async Task<bool> GenerateAsync(
        ValidationResult result,
        string outputPath)
    {
        using var stream = new FileStream(outputPath, FileMode.Create);
        using var document = new Document(PageSize.A4);
        using var writer = PdfWriter.GetInstance(document, stream);

        document.Open();

        // 표지
        AddCoverPage(document, result);

        // 요약
        AddSummaryPage(document, result);

        // 단계별 상세
        AddStageDetails(document, result);

        // 오류 목록
        AddErrorList(document, result);

        // 통계 차트
        AddStatistics(document, result);

        document.Close();

        return true;
    }

    private void AddCoverPage(Document doc, ValidationResult result)
    {
        var titleFont = FontFactory.GetFont(
            FontFactory.HELVETICA_BOLD, 24, BaseColor.BLACK);
        var title = new Paragraph("공간데이터 검수 보고서", titleFont);
        title.Alignment = Element.ALIGN_CENTER;
        title.SpacingAfter = 30f;
        doc.Add(title);

        var infoTable = new PdfPTable(2);
        infoTable.AddCell("검수 대상");
        infoTable.AddCell(result.TargetFile);
        infoTable.AddCell("검수 일시");
        infoTable.AddCell(result.CompletedAt.ToString("yyyy-MM-dd HH:mm:ss"));
        infoTable.AddCell("총 오류 수");
        infoTable.AddCell(result.ErrorCount.ToString());
        doc.Add(infoTable);
    }

    private void AddSummaryPage(Document doc, ValidationResult result)
    {
        // 요약 정보 섹션
        var summaryFont = FontFactory.GetFont(
            FontFactory.HELVETICA_BOLD, 16, BaseColor.BLACK);
        var summaryTitle = new Paragraph("검수 결과 요약", summaryFont);
        summaryTitle.SpacingBefore = 20f;
        doc.Add(summaryTitle);

        // 전체 결과
        var statusColor = result.Status == ValidationStatus.Passed
            ? BaseColor.GREEN : BaseColor.RED;
        var statusChunk = new Chunk(
            result.Status.ToString(),
            FontFactory.GetFont(FontFactory.HELVETICA_BOLD, 14, statusColor));
        doc.Add(new Paragraph(statusChunk));

        // 심각도별 분포
        var severityTable = new PdfPTable(2);
        severityTable.AddCell("심각도");
        severityTable.AddCell("오류 수");

        var errorsBySeverity = result.GetErrorsBySeverity();
        foreach (var kvp in errorsBySeverity)
        {
            severityTable.AddCell(kvp.Key);
            severityTable.AddCell(kvp.Value.ToString());
        }
        doc.Add(severityTable);
    }

    private void AddStageDetails(Document doc, ValidationResult result)
    {
        // 각 단계별 상세 결과
        AddStageDetail(doc, "Stage 0: FileGDB 무결성", result.FileGdbCheckResult);
        AddStageDetail(doc, "Stage 1: 테이블 검사", result.TableCheckResult);
        AddStageDetail(doc, "Stage 2: 스키마 검사", result.SchemaCheckResult);
        AddStageDetail(doc, "Stage 3: 지오메트리 검사", result.GeometryCheckResult);
        AddStageDetail(doc, "Stage 4: 속성 검사", result.AttributeRelationCheckResult);
        AddStageDetail(doc, "Stage 5: 공간 관계 검사", result.RelationCheckResult);
    }

    private void AddErrorList(Document doc, ValidationResult result)
    {
        var errorFont = FontFactory.GetFont(
            FontFactory.HELVETICA_BOLD, 14, BaseColor.BLACK);
        var errorTitle = new Paragraph("상세 오류 목록", errorFont);
        errorTitle.SpacingBefore = 20f;
        doc.Add(errorTitle);

        var errorTable = new PdfPTable(5);
        errorTable.AddCell("오류 코드");
        errorTable.AddCell("심각도");
        errorTable.AddCell("테이블");
        errorTable.AddCell("피처 ID");
        errorTable.AddCell("설명");

        foreach (var error in result.GetAllErrors())
        {
            errorTable.AddCell(error.ErrorCode);
            errorTable.AddCell(error.Severity.ToString());
            errorTable.AddCell(error.TableName);
            errorTable.AddCell(error.FeatureId);
            errorTable.AddCell(error.Message);
        }

        doc.Add(errorTable);
    }
}
```

**예상 시간**: 40-50시간

#### Excel 구현 상세

##### ExcelReportService.cs 구조
```csharp
public class ExcelReportService
{
    public async Task<bool> GenerateAsync(
        ValidationResult result,
        string outputPath)
    {
        using var package = new ExcelPackage();

        // 시트 생성
        CreateSummarySheet(package, result);
        CreateStage0Sheet(package, result.FileGdbCheckResult);
        CreateStage1Sheet(package, result.TableCheckResult);
        CreateStage2Sheet(package, result.SchemaCheckResult);
        CreateStage3Sheet(package, result.GeometryCheckResult);
        CreateStage4Sheet(package, result.AttributeRelationCheckResult);
        CreateStage5Sheet(package, result.RelationCheckResult);
        CreateErrorListSheet(package, result);
        CreateStatisticsSheet(package, result);

        await package.SaveAsAsync(new FileInfo(outputPath));
        return true;
    }

    private void CreateSummarySheet(ExcelPackage package, ValidationResult result)
    {
        var ws = package.Workbook.Worksheets.Add("요약");

        // 헤더
        ws.Cells["A1"].Value = "공간데이터 검수 보고서";
        ws.Cells["A1:D1"].Merge = true;
        ws.Cells["A1"].Style.Font.Size = 18;
        ws.Cells["A1"].Style.Font.Bold = true;
        ws.Cells["A1"].Style.HorizontalAlignment = ExcelHorizontalAlignment.Center;

        // 기본 정보
        int row = 3;
        ws.Cells[row, 1].Value = "검수 대상";
        ws.Cells[row, 2].Value = result.TargetFile;
        row++;

        ws.Cells[row, 1].Value = "검수 일시";
        ws.Cells[row, 2].Value = result.CompletedAt;
        ws.Cells[row, 2].Style.Numberformat.Format = "yyyy-MM-dd HH:mm:ss";
        row++;

        ws.Cells[row, 1].Value = "전체 결과";
        ws.Cells[row, 2].Value = result.Status.ToString();
        ws.Cells[row, 2].Style.Font.Color.SetColor(
            result.Status == ValidationStatus.Passed
                ? Color.Green : Color.Red);
        row++;

        ws.Cells[row, 1].Value = "총 오류 수";
        ws.Cells[row, 2].Value = result.ErrorCount;
        row += 2;

        // 단계별 결과 테이블
        ws.Cells[row, 1].Value = "단계";
        ws.Cells[row, 2].Value = "상태";
        ws.Cells[row, 3].Value = "오류 수";
        ws.Cells[row, 4].Value = "경고 수";
        ws.Cells[row, 1, row, 4].Style.Font.Bold = true;
        ws.Cells[row, 1, row, 4].Style.Fill.PatternType = ExcelFillStyle.Solid;
        ws.Cells[row, 1, row, 4].Style.Fill.BackgroundColor.SetColor(Color.LightGray);
        row++;

        AddStageRow(ws, ref row, "Stage 0: FileGDB 무결성", result.FileGdbCheckResult);
        AddStageRow(ws, ref row, "Stage 1: 테이블 검사", result.TableCheckResult);
        AddStageRow(ws, ref row, "Stage 2: 스키마 검사", result.SchemaCheckResult);
        AddStageRow(ws, ref row, "Stage 3: 지오메트리 검사", result.GeometryCheckResult);
        AddStageRow(ws, ref row, "Stage 4: 속성 검사", result.AttributeRelationCheckResult);
        AddStageRow(ws, ref row, "Stage 5: 공간 관계 검사", result.RelationCheckResult);

        // 열 너비 자동 조정
        ws.Cells[ws.Dimension.Address].AutoFitColumns();
    }

    private void CreateErrorListSheet(ExcelPackage package, ValidationResult result)
    {
        var ws = package.Workbook.Worksheets.Add("오류 목록");

        // 헤더
        ws.Cells["A1"].Value = "오류 코드";
        ws.Cells["B1"].Value = "심각도";
        ws.Cells["C1"].Value = "단계";
        ws.Cells["D1"].Value = "테이블";
        ws.Cells["E1"].Value = "피처 ID";
        ws.Cells["F1"].Value = "설명";

        ws.Cells["A1:F1"].Style.Font.Bold = true;
        ws.Cells["A1:F1"].Style.Fill.PatternType = ExcelFillStyle.Solid;
        ws.Cells["A1:F1"].Style.Fill.BackgroundColor.SetColor(Color.LightBlue);

        // 데이터
        int row = 2;
        foreach (var error in result.GetAllErrors())
        {
            ws.Cells[row, 1].Value = error.ErrorCode;
            ws.Cells[row, 2].Value = error.Severity.ToString();
            ws.Cells[row, 3].Value = error.StageName;
            ws.Cells[row, 4].Value = error.TableName;
            ws.Cells[row, 5].Value = error.FeatureId;
            ws.Cells[row, 6].Value = error.Message;

            // 심각도별 색상
            var severityColor = error.Severity switch
            {
                ErrorSeverity.Critical => Color.Red,
                ErrorSeverity.Major => Color.Orange,
                ErrorSeverity.Minor => Color.Yellow,
                _ => Color.White
            };
            ws.Cells[row, 2].Style.Fill.PatternType = ExcelFillStyle.Solid;
            ws.Cells[row, 2].Style.Fill.BackgroundColor.SetColor(severityColor);

            row++;
        }

        // 필터 추가
        ws.Cells[1, 1, row - 1, 6].AutoFilter = true;

        // 열 너비 조정
        ws.Cells[ws.Dimension.Address].AutoFitColumns();
    }

    private void CreateStatisticsSheet(ExcelPackage package, ValidationResult result)
    {
        var ws = package.Workbook.Worksheets.Add("통계");

        // 심각도별 분포
        ws.Cells["A1"].Value = "심각도별 오류 분포";
        ws.Cells["A1"].Style.Font.Bold = true;

        ws.Cells["A2"].Value = "심각도";
        ws.Cells["B2"].Value = "개수";
        ws.Cells["A2:B2"].Style.Font.Bold = true;

        int row = 3;
        var errorsBySeverity = result.GetErrorsBySeverity();
        foreach (var kvp in errorsBySeverity)
        {
            ws.Cells[row, 1].Value = kvp.Key;
            ws.Cells[row, 2].Value = kvp.Value;
            row++;
        }

        // 파이 차트 추가
        var chart = ws.Drawings.AddChart("심각도별 분포", eChartType.Pie);
        chart.SetPosition(1, 0, 3, 0);
        chart.SetSize(400, 300);
        chart.Series.Add(ws.Cells[$"B3:B{row-1}"], ws.Cells[$"A3:A{row-1}"]);
        chart.Title.Text = "심각도별 오류 분포";

        // 오류 유형별 분포
        row += 2;
        ws.Cells[row, 1].Value = "오류 유형별 분포";
        ws.Cells[row, 1].Style.Font.Bold = true;
        row++;

        ws.Cells[row, 1].Value = "오류 유형";
        ws.Cells[row, 2].Value = "개수";
        ws.Cells[row, 1, row, 2].Style.Font.Bold = true;
        row++;

        var startRow = row;
        var errorsByType = result.GetErrorsByType();
        foreach (var kvp in errorsByType)
        {
            ws.Cells[row, 1].Value = kvp.Key;
            ws.Cells[row, 2].Value = kvp.Value;
            row++;
        }

        // 막대 차트 추가
        var barChart = ws.Drawings.AddChart("유형별 분포", eChartType.ColumnClustered);
        barChart.SetPosition(startRow - 2, 0, 3, 0);
        barChart.SetSize(400, 300);
        barChart.Series.Add(ws.Cells[$"B{startRow}:B{row-1}"], ws.Cells[$"A{startRow}:A{row-1}"]);
        barChart.Title.Text = "오류 유형별 분포";
    }
}
```

**예상 시간**: 30-40시간

---

### P2-1: AttributeCheckProcessor 완성

#### 목표
`4_attribute_check.csv`의 93개 속성 관계 규칙을 완전히 구현

#### 구현 전략

##### 규칙 구조 예시
```csv
RuleID,SourceTable,SourceField,Condition,TargetTable,TargetField,RelationType,ErrorMessage
ATTR001,A0010000,A001_001,NOT NULL,,,SELF,A001_001 필드는 필수입니다
ATTR002,A0010000,A001_002,IN_CODELIST,CODELIST,A001_002,LOOKUP,유효하지 않은 코드값입니다
ATTR003,A0010000,A001_003,>=,A0010000,A001_004,SELF,시작값이 종료값보다 큽니다
ATTR004,A0010000,A001_005,EXISTS,A0020000,A002_001,FK,참조 무결성 위반
```

##### 구현 단계

**1단계: 규칙 파서 구현 (10h)**
```csharp
public class AttributeRuleParser
{
    public List<AttributeRule> ParseRules(List<AttributeCheckConfig> configs)
    {
        var rules = new List<AttributeRule>();

        foreach (var config in configs)
        {
            var rule = new AttributeRule
            {
                RuleId = config.RuleID,
                SourceTable = config.SourceTable,
                SourceField = config.SourceField,
                Condition = ParseCondition(config.Condition),
                TargetTable = config.TargetTable,
                TargetField = config.TargetField,
                RelationType = ParseRelationType(config.RelationType),
                ErrorMessage = config.ErrorMessage
            };

            rules.Add(rule);
        }

        return rules;
    }

    private ConditionType ParseCondition(string condition)
    {
        return condition.ToUpper() switch
        {
            "NOT NULL" => ConditionType.NotNull,
            "IN_CODELIST" => ConditionType.InCodelist,
            ">=" => ConditionType.GreaterOrEqual,
            "<=" => ConditionType.LessOrEqual,
            "=" => ConditionType.Equal,
            "EXISTS" => ConditionType.Exists,
            _ => throw new NotSupportedException($"Unsupported condition: {condition}")
        };
    }
}
```

**2단계: 규칙 평가 엔진 (20h)**
```csharp
public class AttributeRuleEvaluator
{
    private readonly Dictionary<string, HashSet<string>> _codelists;
    private readonly IDataProvider _dataProvider;

    public async Task<List<ValidationError>> EvaluateRuleAsync(
        AttributeRule rule,
        Layer sourceLayer,
        CancellationToken cancellationToken)
    {
        var errors = new List<ValidationError>();

        sourceLayer.ResetReading();
        while (sourceLayer.GetNextFeature() is Feature feature)
        {
            if (cancellationToken.IsCancellationRequested) break;

            var error = await EvaluateFeatureAsync(rule, feature);
            if (error != null)
                errors.Add(error);
        }

        return errors;
    }

    private async Task<ValidationError?> EvaluateFeatureAsync(
        AttributeRule rule,
        Feature feature)
    {
        var sourceValue = GetFieldValue(feature, rule.SourceField);

        return rule.Condition switch
        {
            ConditionType.NotNull => EvaluateNotNull(sourceValue, rule, feature),
            ConditionType.InCodelist => EvaluateInCodelist(sourceValue, rule, feature),
            ConditionType.GreaterOrEqual => EvaluateComparison(sourceValue, rule, feature, (a, b) => a >= b),
            ConditionType.Exists => await EvaluateExists(sourceValue, rule, feature),
            _ => null
        };
    }

    private ValidationError? EvaluateNotNull(
        object? value,
        AttributeRule rule,
        Feature feature)
    {
        if (value == null || string.IsNullOrWhiteSpace(value.ToString()))
        {
            return new ValidationError
            {
                ErrorCode = rule.RuleId,
                Severity = ErrorSeverity.Critical,
                TableName = rule.SourceTable,
                FeatureId = feature.GetFID().ToString(),
                Message = rule.ErrorMessage
            };
        }
        return null;
    }

    private ValidationError? EvaluateInCodelist(
        object? value,
        AttributeRule rule,
        Feature feature)
    {
        if (value == null) return null;

        var codelistKey = rule.TargetField; // Codelist 식별자
        if (!_codelists.TryGetValue(codelistKey, out var validCodes))
        {
            throw new InvalidOperationException($"Codelist not found: {codelistKey}");
        }

        if (!validCodes.Contains(value.ToString()!))
        {
            return new ValidationError
            {
                ErrorCode = rule.RuleId,
                Severity = ErrorSeverity.Major,
                TableName = rule.SourceTable,
                FeatureId = feature.GetFID().ToString(),
                Message = $"{rule.ErrorMessage} (값: {value})"
            };
        }
        return null;
    }

    private async Task<ValidationError?> EvaluateExists(
        object? value,
        AttributeRule rule,
        Feature feature)
    {
        if (value == null) return null;

        // 참조 테이블에서 값 존재 여부 확인
        var targetLayer = await _dataProvider.GetLayerAsync(rule.TargetTable);
        targetLayer.SetAttributeFilter($"{rule.TargetField} = '{value}'");
        var count = targetLayer.GetFeatureCount(1);

        if (count == 0)
        {
            return new ValidationError
            {
                ErrorCode = rule.RuleId,
                Severity = ErrorSeverity.Major,
                TableName = rule.SourceTable,
                FeatureId = feature.GetFID().ToString(),
                Message = $"{rule.ErrorMessage} (참조값: {value})"
            };
        }
        return null;
    }
}
```

**3단계: ConditionalRuleEngine 통합 (15h)**
```csharp
public class ConditionalRuleEngine
{
    public async Task<bool> EvaluateConditionAsync(
        string condition,
        Feature feature,
        Dictionary<string, object> context)
    {
        // 복잡한 조건 표현식 파싱 및 평가
        // 예: "A001_001 > 100 AND A001_002 IN ('01', '02')"

        var expression = ParseExpression(condition);
        return await expression.EvaluateAsync(feature, context);
    }
}
```

**4단계: 병렬 처리 및 최적화 (10h)**
```csharp
public async Task<List<ValidationError>> ValidateAsync(
    string gdbPath,
    List<AttributeCheckConfig> rules,
    CancellationToken token)
{
    var allErrors = new ConcurrentBag<ValidationError>();

    // 테이블별로 규칙 그룹화
    var rulesByTable = rules.GroupBy(r => r.SourceTable);

    await Parallel.ForEachAsync(
        rulesByTable,
        new ParallelOptions
        {
            MaxDegreeOfParallelism = Environment.ProcessorCount,
            CancellationToken = token
        },
        async (tableRules, ct) =>
        {
            using var ds = Gdal.OpenEx(gdbPath, 0, null, null, null);
            var layer = ds.GetLayerByName(tableRules.Key);

            foreach (var rule in tableRules)
            {
                var errors = await EvaluateRuleAsync(rule, layer, ct);
                foreach (var error in errors)
                    allErrors.Add(error);
            }
        });

    return allErrors.ToList();
}
```

**예상 시간**: 50-60시간

---

### P2-2: RelationCheckProcessor 완성

#### 목표
`5_relation_check.csv`의 20개 공간 관계 규칙을 완전히 구현

#### 공간 관계 타입
- **Case1**: Intersects, Contains, Within, Touches, Crosses, Overlaps
- **Case2**: Buffer 기반 관계 (예: A가 B로부터 10m 이내에 있어야 함)
- **Case3**: Topology 규칙 (예: A의 경계가 B에 완전히 포함되어야 함)

#### 구현 단계

**1단계: 공간 인덱스 구축 (15h)**
```csharp
public class SpatialRelationValidator
{
    private readonly SpatialIndexManager _indexManager;

    public async Task<SpatialIndex> BuildIndexAsync(
        Layer layer,
        CancellationToken token)
    {
        var index = _indexManager.CreateIndex(IndexType.RTree);

        layer.ResetReading();
        while (layer.GetNextFeature() is Feature feature)
        {
            if (token.IsCancellationRequested) break;

            var envelope = new Envelope();
            feature.GetGeometryRef().GetEnvelope(envelope);

            index.Insert(
                feature.GetFID(),
                envelope.MinX, envelope.MinY,
                envelope.MaxX, envelope.MaxY);
        }

        return index;
    }
}
```

**2단계: Case1 - 기본 공간 관계 (15h)**
```csharp
private async Task<List<ValidationError>> ValidateCase1Async(
    RelationCheckConfig rule,
    Layer sourceLayer,
    Layer targetLayer,
    SpatialIndex targetIndex)
{
    var errors = new List<ValidationError>();

    sourceLayer.ResetReading();
    while (sourceLayer.GetNextFeature() is Feature sourceFeature)
    {
        var sourceGeom = sourceFeature.GetGeometryRef();
        var envelope = new Envelope();
        sourceGeom.GetEnvelope(envelope);

        // 공간 인덱스로 후보 검색
        var candidates = targetIndex.Query(
            envelope.MinX, envelope.MinY,
            envelope.MaxX, envelope.MaxY);

        bool relationFound = false;
        foreach (var candidateId in candidates)
        {
            var targetFeature = targetLayer.GetFeature(candidateId);
            var targetGeom = targetFeature.GetGeometryRef();

            // 실제 공간 관계 검사
            relationFound = rule.RelationType switch
            {
                "Intersects" => sourceGeom.Intersects(targetGeom),
                "Contains" => sourceGeom.Contains(targetGeom),
                "Within" => sourceGeom.Within(targetGeom),
                "Touches" => sourceGeom.Touches(targetGeom),
                "Crosses" => sourceGeom.Crosses(targetGeom),
                "Overlaps" => sourceGeom.Overlaps(targetGeom),
                _ => false
            };

            if (relationFound) break;
        }

        if (!relationFound)
        {
            errors.Add(new ValidationError
            {
                ErrorCode = rule.RuleID,
                Severity = ErrorSeverity.Major,
                TableName = rule.SourceTable,
                FeatureId = sourceFeature.GetFID().ToString(),
                Message = $"{rule.ErrorMessage} (관계: {rule.RelationType})"
            });
        }
    }

    return errors;
}
```

**3단계: Case2 - Buffer 기반 관계 (12h)**
```csharp
private async Task<List<ValidationError>> ValidateCase2Async(
    RelationCheckConfig rule,
    Layer sourceLayer,
    Layer targetLayer,
    double bufferDistance)
{
    var errors = new List<ValidationError>();

    sourceLayer.ResetReading();
    while (sourceLayer.GetNextFeature() is Feature sourceFeature)
    {
        var sourceGeom = sourceFeature.GetGeometryRef();
        var bufferedGeom = sourceGeom.Buffer(bufferDistance, 30);

        // Buffer 영역 내 대상 객체 검색
        targetLayer.SetSpatialFilter(bufferedGeom);
        var count = targetLayer.GetFeatureCount(1);

        if (count == 0)
        {
            errors.Add(new ValidationError
            {
                ErrorCode = rule.RuleID,
                Severity = ErrorSeverity.Minor,
                TableName = rule.SourceTable,
                FeatureId = sourceFeature.GetFID().ToString(),
                Message = $"{rule.ErrorMessage} (버퍼 거리: {bufferDistance}m)"
            });
        }

        targetLayer.SetSpatialFilter(null);
    }

    return errors;
}
```

**4단계: Case3 - 토폴로지 규칙 (13h)**
```csharp
private async Task<List<ValidationError>> ValidateCase3Async(
    RelationCheckConfig rule,
    Layer sourceLayer,
    Layer targetLayer)
{
    var errors = new List<ValidationError>();

    // 예: 폴리곤의 경계가 라인에 완전히 포함되어야 함
    sourceLayer.ResetReading();
    while (sourceLayer.GetNextFeature() is Feature sourceFeature)
    {
        var sourceGeom = sourceFeature.GetGeometryRef();
        var sourceBoundary = sourceGeom.GetBoundary();

        // 모든 타겟 라인 병합
        var targetUnion = CombineTargetGeometries(targetLayer);

        // 경계가 완전히 포함되는지 확인
        if (!sourceBoundary.Within(targetUnion))
        {
            errors.Add(new ValidationError
            {
                ErrorCode = rule.RuleID,
                Severity = ErrorSeverity.Critical,
                TableName = rule.SourceTable,
                FeatureId = sourceFeature.GetFID().ToString(),
                Message = rule.ErrorMessage
            });
        }
    }

    return errors;
}
```

**5단계: 병렬 처리 및 통합 (5h)**

**예상 시간**: 50-60시간

---

### P2-3: GdbToSqliteConverter 완전 구현

#### 목표
FileGDB를 SQLite/SpatiaLite로 완전히 변환하여 고성능 쿼리 지원

#### 구현 단계

**1단계: SpatiaLite 초기화 (8h)**
```csharp
private void InitializeSpatiaLite(SqliteConnection connection)
{
    connection.Open();

    // SpatiaLite 확장 로드
    connection.LoadExtension("mod_spatialite");

    // 공간 메타데이터 초기화
    using var cmd = connection.CreateCommand();
    cmd.CommandText = "SELECT InitSpatialMetaData(1)";
    cmd.ExecuteNonQuery();
}
```

**2단계: 스키마 변환 (12h)**
```csharp
private void CreateTableSchema(
    Layer layer,
    SqliteConnection connection,
    string tableName)
{
    var layerDefn = layer.GetLayerDefn();
    var columns = new List<string>();

    // 필드 정의 변환
    for (int i = 0; i < layerDefn.GetFieldCount(); i++)
    {
        var fieldDefn = layerDefn.GetFieldDefn(i);
        var fieldName = fieldDefn.GetName();
        var fieldType = MapOgrTypeToSqliteType(fieldDefn.GetFieldType());

        columns.Add($"{fieldName} {fieldType}");
    }

    // 테이블 생성
    using var cmd = connection.CreateCommand();
    cmd.CommandText = $@"
        CREATE TABLE {tableName} (
            fid INTEGER PRIMARY KEY AUTOINCREMENT,
            {string.Join(",\n            ", columns)}
        )";
    cmd.ExecuteNonQuery();

    // 지오메트리 컬럼 추가
    var geomType = layer.GetGeomType();
    var srs = layer.GetSpatialRef();
    var epsg = GetEpsgCode(srs);

    cmd.CommandText = $@"
        SELECT AddGeometryColumn(
            '{tableName}',
            'geometry',
            {epsg},
            '{MapGeometryType(geomType)}',
            'XY'
        )";
    cmd.ExecuteNonQuery();

    // 공간 인덱스 생성
    cmd.CommandText = $"SELECT CreateSpatialIndex('{tableName}', 'geometry')";
    cmd.ExecuteNonQuery();
}

private string MapOgrTypeToSqliteType(FieldType ogrType)
{
    return ogrType switch
    {
        FieldType.OFTInteger => "INTEGER",
        FieldType.OFTInteger64 => "INTEGER",
        FieldType.OFTReal => "REAL",
        FieldType.OFTString => "TEXT",
        FieldType.OFTDate => "TEXT",
        FieldType.OFTDateTime => "TEXT",
        FieldType.OFTBinary => "BLOB",
        _ => "TEXT"
    };
}
```

**3단계: 데이터 변환 (15h)**
```csharp
private async Task CopyLayerDataAsync(
    Layer layer,
    SqliteConnection connection,
    string tableName,
    IProgress<int> progress,
    CancellationToken cancellationToken)
{
    var layerDefn = layer.GetLayerDefn();
    var fieldCount = layerDefn.GetFieldCount();

    // 필드명 목록
    var fieldNames = new List<string>();
    for (int i = 0; i < fieldCount; i++)
    {
        fieldNames.Add(layerDefn.GetFieldDefn(i).GetName());
    }

    // INSERT 문 준비
    var placeholders = string.Join(", ", Enumerable.Range(0, fieldCount + 1).Select(i => $"@p{i}"));
    var insertSql = $@"
        INSERT INTO {tableName} ({string.Join(", ", fieldNames)}, geometry)
        VALUES ({placeholders})";

    using var transaction = connection.BeginTransaction();
    using var cmd = connection.CreateCommand();
    cmd.CommandText = insertSql;

    int processedCount = 0;
    int totalCount = (int)layer.GetFeatureCount(1);

    layer.ResetReading();
    while (layer.GetNextFeature() is Feature feature)
    {
        if (cancellationToken.IsCancellationRequested)
        {
            transaction.Rollback();
            throw new OperationCanceledException();
        }

        cmd.Parameters.Clear();

        // 속성 값 바인딩
        for (int i = 0; i < fieldCount; i++)
        {
            var value = GetFieldValueAsObject(feature, i);
            cmd.Parameters.AddWithValue($"@p{i}", value ?? DBNull.Value);
        }

        // 지오메트리 바인딩 (WKB)
        var geom = feature.GetGeometryRef();
        if (geom != null)
        {
            var wkb = new byte[geom.WkbSize()];
            geom.ExportToWkb(wkb);
            cmd.Parameters.AddWithValue($"@p{fieldCount}", wkb);
        }
        else
        {
            cmd.Parameters.AddWithValue($"@p{fieldCount}", DBNull.Value);
        }

        await cmd.ExecuteNonQueryAsync(cancellationToken);

        processedCount++;
        if (processedCount % 1000 == 0)
        {
            progress?.Report((int)((double)processedCount / totalCount * 100));
        }
    }

    transaction.Commit();
}

private object? GetFieldValueAsObject(Feature feature, int fieldIndex)
{
    if (!feature.IsFieldSet(fieldIndex))
        return null;

    var fieldDefn = feature.GetDefnRef().GetFieldDefn(fieldIndex);
    return fieldDefn.GetFieldType() switch
    {
        FieldType.OFTInteger => feature.GetFieldAsInteger(fieldIndex),
        FieldType.OFTInteger64 => feature.GetFieldAsInteger64(fieldIndex),
        FieldType.OFTReal => feature.GetFieldAsDouble(fieldIndex),
        FieldType.OFTString => feature.GetFieldAsString(fieldIndex),
        _ => feature.GetFieldAsString(fieldIndex)
    };
}
```

**4단계: 병렬 테이블 변환 (10h)**
```csharp
public async Task<string> ConvertAsync(
    string gdbPath,
    IProgress<ConversionProgress> progress,
    CancellationToken cancellationToken)
{
    var tempPath = Path.Combine(Path.GetTempPath(), $"temp_{Guid.NewGuid()}.sqlite");

    using var connection = new SqliteConnection($"Data Source={tempPath}");
    InitializeSpatiaLite(connection);

    using var ds = Gdal.OpenEx(gdbPath, 0, null, null, null);
    var layerCount = ds.GetLayerCount();

    for (int i = 0; i < layerCount; i++)
    {
        if (cancellationToken.IsCancellationRequested)
        {
            File.Delete(tempPath);
            throw new OperationCanceledException();
        }

        var layer = ds.GetLayerByIndex(i);
        var layerName = layer.GetName();

        _logger.LogInformation("레이어 변환 중: {LayerName} ({Current}/{Total})",
            layerName, i + 1, layerCount);

        CreateTableSchema(layer, connection, layerName);

        await CopyLayerDataAsync(
            layer,
            connection,
            layerName,
            new Progress<int>(p => progress?.Report(new ConversionProgress
            {
                CurrentLayer = layerName,
                LayerIndex = i,
                TotalLayers = layerCount,
                LayerProgress = p
            })),
            cancellationToken);
    }

    connection.Close();

    _logger.LogInformation("변환 완료: {OutputPath}", tempPath);
    return tempPath;
}
```

**예상 시간**: 40-60시간

---

## 아키텍처 개선 권고

### 1. Reflection 기반 Stage 제어 제거

**현재 문제**:
```csharp
// SimpleValidationService.cs Line 909-920
private bool ShouldRunStage(int stageNumber)
{
    try
    {
        var mainWindow = Application.Current.MainWindow;
        var checkBoxName = $"cbStage{stageNumber}";
        var checkBox = mainWindow?.FindName(checkBoxName) as CheckBox;
        return checkBox?.IsChecked ?? false;
    }
    catch
    {
        return false;
    }
}
```

**개선 방안**:
```csharp
// 1. 인터페이스 정의
public interface IStageConfiguration
{
    bool IsStageEnabled(int stageNumber);
}

// 2. ViewModel 구현
public class ValidationConfigViewModel : IStageConfiguration
{
    public bool Stage0Enabled { get; set; } = true;
    public bool Stage1Enabled { get; set; } = true;
    public bool Stage2Enabled { get; set; } = true;
    public bool Stage3Enabled { get; set; } = true;
    public bool Stage4Enabled { get; set; } = true;
    public bool Stage5Enabled { get; set; } = true;

    public bool IsStageEnabled(int stageNumber)
    {
        return stageNumber switch
        {
            0 => Stage0Enabled,
            1 => Stage1Enabled,
            2 => Stage2Enabled,
            3 => Stage3Enabled,
            4 => Stage4Enabled,
            5 => Stage5Enabled,
            _ => false
        };
    }
}

// 3. DI 주입
public class SimpleValidationService
{
    private readonly IStageConfiguration _stageConfig;

    public SimpleValidationService(IStageConfiguration stageConfig)
    {
        _stageConfig = stageConfig;
    }

    private bool ShouldRunStage(int stageNumber)
    {
        return _stageConfig.IsStageEnabled(stageNumber);
    }
}
```

---

### 2. Dynamic Casting 제거

**현재 문제**:
```csharp
// StageParallelProcessingManager.cs
var result = await processor.ProcessAsync((dynamic)filePath, (dynamic)config, cancellationToken);
```

**개선 방안**:
```csharp
// 1. 공통 인터페이스
public interface IValidationProcessor<TConfig>
{
    Task<CheckResult> ProcessAsync(string filePath, TConfig config, CancellationToken cancellationToken);
}

// 2. 제네릭 실행기
public class StageExecutor<TConfig>
{
    private readonly IValidationProcessor<TConfig> _processor;

    public async Task<CheckResult> ExecuteAsync(
        string filePath,
        TConfig config,
        CancellationToken cancellationToken)
    {
        return await _processor.ProcessAsync(filePath, config, cancellationToken);
    }
}
```

---

### 3. 코드 중복 제거

병렬 실행과 순차 실행 로직 통합:

```csharp
public async Task<ValidationResult> ValidateAsync(
    string filePath,
    bool useParallel = false)
{
    var executor = useParallel
        ? (IStageExecutor)new ParallelStageExecutor(_parallelManager)
        : new SequentialStageExecutor();

    return await executor.ExecuteAllStagesAsync(filePath, _configs);
}
```

---

## 테스트 전략

### 단위 테스트 (Unit Tests)

#### 1. Processor별 테스트
```csharp
[TestClass]
public class SchemaCheckProcessorTests
{
    [TestMethod]
    public async Task ValidateAsync_MissingColumn_ReturnsError()
    {
        // Arrange
        var processor = new SchemaCheckProcessor();
        var config = new SchemaCheckConfig
        {
            TableName = "TestTable",
            RequiredFields = new[] { "OBJECTID", "SHAPE", "NAME" }
        };

        // Act
        var result = await processor.ProcessAsync(TestData.GdbPath, config);

        // Assert
        Assert.IsFalse(result.IsValid);
        Assert.AreEqual(1, result.Errors.Count);
        Assert.AreEqual("SCH001", result.Errors[0].ErrorCode);
    }

    [TestMethod]
    public async Task ValidateAsync_WrongDataType_ReturnsError()
    {
        // Test data type mismatch detection
    }

    [TestMethod]
    public async Task ValidateAsync_PrimaryKeyDuplicate_ReturnsError()
    {
        // Test PK uniqueness validation
    }
}
```

#### 2. 서비스 로직 테스트
```csharp
[TestClass]
public class QcErrorServiceTests
{
    [TestMethod]
    public async Task SaveGeometryValidationResultsAsync_CreatesQcErrors()
    {
        // Test QC error creation and storage
    }

    [TestMethod]
    public async Task ClassifyErrors_SeparatesGeometryAndNonGeometry()
    {
        // Test error classification logic
    }
}
```

#### 3. 변환기 테스트
```csharp
[TestClass]
public class GdbToSqliteConverterTests
{
    [TestMethod]
    public async Task ConvertAsync_PreservesSchema()
    {
        // Verify schema is correctly converted
    }

    [TestMethod]
    public async Task ConvertAsync_PreservesData()
    {
        // Verify all features are copied
    }

    [TestMethod]
    public async Task ConvertAsync_PreservesGeometry()
    {
        // Verify geometries are correctly converted to WKB
    }
}
```

---

### 통합 테스트 (Integration Tests)

#### 1. 전체 검수 프로세스
```csharp
[TestClass]
public class ValidationIntegrationTests
{
    [TestMethod]
    public async Task EndToEnd_ValidGdb_ReturnsSuccess()
    {
        // Test complete validation workflow
        var service = new SimpleValidationService(/* dependencies */);
        var result = await service.ValidateAsync(TestData.ValidGdbPath);

        Assert.IsTrue(result.IsValid);
        Assert.AreEqual(0, result.ErrorCount);
    }

    [TestMethod]
    public async Task EndToEnd_InvalidGdb_ReturnsErrors()
    {
        // Test validation with known errors
        var service = new SimpleValidationService(/* dependencies */);
        var result = await service.ValidateAsync(TestData.InvalidGdbPath);

        Assert.IsFalse(result.IsValid);
        Assert.IsTrue(result.ErrorCount > 0);
    }
}
```

#### 2. 보고서 생성
```csharp
[TestClass]
public class ReportGenerationIntegrationTests
{
    [TestMethod]
    public async Task GeneratePdf_CreatesValidFile()
    {
        var service = new PdfReportService();
        var outputPath = Path.Combine(Path.GetTempPath(), "test_report.pdf");

        var success = await service.GenerateAsync(TestData.ValidationResult, outputPath);

        Assert.IsTrue(success);
        Assert.IsTrue(File.Exists(outputPath));
        Assert.IsTrue(new FileInfo(outputPath).Length > 1024); // At least 1KB
    }
}
```

---

### 성능 테스트 (Performance Tests)

#### 1. 대용량 파일 처리
```csharp
[TestClass]
public class PerformanceTests
{
    [TestMethod]
    [Timeout(300000)] // 5 minutes
    public async Task ValidateAsync_LargeGdb_CompletesInTime()
    {
        // Test with 1GB+ GDB file
        var service = new SimpleValidationService(/* dependencies */);
        var result = await service.ValidateAsync(TestData.LargeGdbPath);

        Assert.IsNotNull(result);
    }

    [TestMethod]
    public async Task GdbToSqlite_Conversion_IsFasterThanDirect()
    {
        // Compare performance: SQLite vs direct GDB access
    }
}
```

#### 2. 메모리 사용량
```csharp
[TestMethod]
public async Task ValidateAsync_LargeGdb_StaysWithinMemoryLimit()
{
    var initialMemory = GC.GetTotalMemory(true);

    var service = new SimpleValidationService(/* dependencies */);
    await service.ValidateAsync(TestData.LargeGdbPath);

    var finalMemory = GC.GetTotalMemory(true);
    var memoryIncrease = finalMemory - initialMemory;

    // Should not exceed 2GB
    Assert.IsTrue(memoryIncrease < 2L * 1024 * 1024 * 1024);
}
```

---

## 예상 일정 및 리소스

### Phase 1: 긴급 수정 (3-4주)

**목표**: 프로덕션 최소 요구사항 충족

| 작업 | 담당 | 예상 시간 | 비고 |
|------|------|----------|------|
| SchemaCheckProcessor 구현 | 개발자 A | 40h | P1-1 |
| PdfReportService 구현 | 개발자 B | 50h | P1-2 |
| ExcelReportService 구현 | 개발자 B | 40h | P1-3 |
| 통합 테스트 | QA | 20h | |
| **소계** | | **150h** | **약 4주** |

---

### Phase 2: 핵심 기능 완성 (5-6주)

**목표**: 모든 검수 단계 완전 구현

| 작업 | 담당 | 예상 시간 | 비고 |
|------|------|----------|------|
| AttributeCheckProcessor 완성 | 개발자 A | 60h | P2-1 |
| RelationCheckProcessor 완성 | 개발자 C | 60h | P2-2 |
| GdbToSqliteConverter 구현 | 개발자 D | 60h | P2-3 |
| 성능 테스트 및 최적화 | 전체 | 40h | |
| **소계** | | **220h** | **약 6주** |

---

### Phase 3: 품질 개선 (4-5주)

**목표**: 유지보수성 및 확장성 향상

| 작업 | 담당 | 예상 시간 | 비고 |
|------|------|----------|------|
| 아키텍처 리팩토링 | 개발자 A | 40h | P3-1 |
| 단위 테스트 구축 | 전체 | 80h | P3-2 |
| HtmlReportService 구현 | 개발자 B | 40h | P3-3 |
| 성능 프로파일링 및 개선 | 개발자 C | 30h | P3-4 |
| 문서 동기화 | Tech Writer | 15h | P3-5 |
| **소계** | | **205h** | **약 5주** |

---

### 총 예상 일정

| Phase | 기간 | 누적 시간 | 팀 규모 |
|-------|------|----------|---------|
| Phase 1 | 4주 | 150h | 2명 |
| Phase 2 | 6주 | 370h | 4명 |
| Phase 3 | 5주 | 575h | 4명 |
| **총계** | **15주** | **575h** | **최대 4명** |

---

## 우선순위 로드맵

### Milestone 1: MVP (4주)
- ✅ SchemaCheckProcessor
- ✅ PdfReportService
- ✅ ExcelReportService
- **결과**: 기본적인 검수 및 보고서 생성 가능

### Milestone 2: 완전한 검수 (10주)
- ✅ AttributeCheckProcessor
- ✅ RelationCheckProcessor
- ✅ GdbToSqliteConverter
- **결과**: 모든 검수 단계 완전 작동

### Milestone 3: 프로덕션 준비 (15주)
- ✅ 아키텍처 리팩토링
- ✅ 단위 테스트 커버리지 80%+
- ✅ HtmlReportService
- ✅ 성능 최적화
- **결과**: 프로덕션 배포 가능

---

## 리스크 및 완화 전략

### 리스크 1: GDAL C# 바인딩 복잡도
**완화**:
- 초기 프로토타입으로 기술 검증
- GDAL 전문가 자문
- Fallback 전략 수립

### 리스크 2: 대용량 데이터 처리 성능
**완화**:
- 초기 성능 벤치마크 수립
- 스트리밍 처리 우선 적용
- 메모리 프로파일링 지속

### 리스크 3: 복잡한 속성/관계 규칙
**완화**:
- 단순 규칙부터 점진적 구현
- 규칙별 단위 테스트 필수
- CSV 규칙 문서화 강화

---

## 결론

SpatialCheckPro는 **견고한 아키텍처 기반**을 가지고 있지만, **핵심 검증 로직의 구현 완성**이 필요합니다.

### 즉시 조치가 필요한 항목
1. ✅ SchemaCheckProcessor 완전 구현
2. ✅ PDF/Excel 보고서 생성 구현
3. ✅ 속성/관계 검사 로직 완성

### 권장 접근 방식
- **Phase 1 (4주)**: 긴급 수정 - 최소 프로덕션 요구사항
- **Phase 2 (6주)**: 핵심 기능 완성 - 모든 검수 단계 작동
- **Phase 3 (5주)**: 품질 개선 - 유지보수성 및 확장성

**총 예상 투입**: 15주, 4명 개발자, 575시간

---

**문서 끝**
